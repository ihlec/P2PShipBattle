<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Warfare Engine v2.1 (Complete)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: 'Courier New', Courier, monospace; color: #eee; user-select: none; }
        canvas { display: block; image-rendering: pixelated; }
        #ui-layer { position: absolute; top: 10px; left: 10px; pointer-events: none; }
        .stat-box { background: rgba(0, 0, 0, 0.7); padding: 10px; border: 2px solid #555; margin-bottom: 5px; pointer-events: auto; }
        #inventory-bar { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 5px; background: rgba(0,0,0,0.8); padding: 10px; border-radius: 8px; pointer-events: auto; }
        .slot { width: 50px; height: 50px; border: 2px solid #444; cursor: pointer; display: flex; justify-content: center; align-items: center; font-size: 10px; position: relative; flex-direction: column; transition: border-color 0.2s; }
        .slot.active { border-color: #ffd700; box-shadow: 0 0 10px #ffd700; }
        .slot-color { width: 20px; height: 20px; border: 1px solid #000; margin-bottom: 2px; }
        .qty { position: absolute; bottom: 2px; right: 2px; font-weight: bold; font-size: 9px;}
        .short-name { font-size: 10px; color: #aaa; text-transform: uppercase; }
        #messages { position: absolute; top: 10%; width: 100%; text-align: center; font-size: 24px; text-shadow: 2px 2px 0 #000; pointer-events: none; transition: opacity 1s; }
        #blueprint-menu { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.95); border: 2px solid #777; padding: 20px; grid-template-columns: repeat(3, 1fr); gap: 10px; pointer-events: auto; z-index: 100; box-shadow: 0 0 20px #000; }
        .bp-item { border: 1px solid #444; padding: 10px; text-align: center; cursor: pointer; transition: background 0.2s; }
        .bp-item:hover { background: #333; border-color: #fff; }
        
        /* New Styles for Disabled State */
        .bp-item.disabled { opacity: 0.4; cursor: not-allowed; border-color: #444; }
        .bp-item.disabled:hover { background: transparent; border-color: #444; }

        .bp-name { font-weight: bold; margin-bottom: 5px; color: #ffd700; }
        .bp-req { font-size: 10px; color: #ccc; }
        #hammer-btn { position: absolute; bottom: 30px; left: 20px; width: 50px; height: 50px; background: rgba(0,0,0,0.8); border: 2px solid #444; border-radius: 8px; font-size: 24px; color: #eee; cursor: pointer; pointer-events: auto; z-index: 100; display: flex; justify-content: center; align-items: center; transition: all 0.2s; }
        #hammer-btn:hover { border-color: #fff; background: #333; transform: scale(1.1); }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="stat-box">
            <div>Health: <span id="hp">100</span></div>
            <div>Pos: <span id="coords">0, 0</span></div>
            <div>Seed: <span id="seed-disp"></span></div>
        </div>
        <div class="stat-box">
            <small>WASD: Move | Click: Build | R-Click: Break</small>
            <div id="active-bp-display" style="color: #ffd700; font-size: 12px; display:none; margin-top:5px;">
                Active: <span id="current-bp-name"></span>
            </div>
        </div>
    </div>

    <div id="messages"></div>
    <button id="hammer-btn" onclick="toggleBlueprints()" title="Open Blueprints">ðŸ”¨</button>

    <div id="blueprint-menu"></div>
    <div id="inventory-bar"></div>
    <canvas id="gameCanvas"></canvas>

<script>
// --- CONSTANTS & CONFIG ---
const CONFIG = {
    TILE_SIZE: 32,
    PLAYER_SPEED_BASE: 4,
    PLAYER_SPEED_ROAD: 8,
    NPC_SPAWN_RATE: 0.005,
    BUILD_RANGE: 400,
    MAX_NPCS: 30
};

const TILES = {
    WATER: { id: 0, color: '#2b2b96', solid: true, name: 'Ocean', short: 'H2O' },
    GRASS: { id: 1, color: '#2d6e32', solid: false, name: 'Grass', short: 'Grs' },
    SAND:  { id: 2, color: '#c2b280', solid: false, name: 'Sand', short: 'Snd' },
    GREY:  { id: 3, color: '#777777', solid: false, name: 'Stone/Road', short: 'Stn' },
    BLACK: { id: 4, color: '#111111', solid: false, name: 'Obsidian', short: 'Obs' }, 
    IRON:  { id: 5, color: '#444444', solid: false, name: 'Iron', short: 'Irn' }, 
    GOLD:  { id: 7, color: '#ffd700', solid: false, name: 'Gold', short: 'Gld' },
    WALL:  { id: 9, color: '#555555', solid: true, name: 'Wall', short: 'Wal' },
    WOOD:  { id: 10, color: '#8B4513', solid: false, name: 'Wood', short: 'Wod' },
    STONE_BLOCK: { id: 11, color: '#777777', solid: false, name: 'Stone Block', short: 'StB' }, 
    TOWER_BASE_STONE: { id: 12, color: '#555555', solid: true, name: 'Stone Tower', short: 'T.St' },
    TOWER_BASE_IRON:  { id: 14, color: '#333333', solid: true, name: 'Iron Tower', short: 'T.Ir' },
    TOWER_BASE_GOLD:  { id: 15, color: '#886600', solid: true, name: 'Gold Tower', short: 'T.Gd' },
    ROOF: { id: 13, color: '#5C3317', solid: false, name: 'Roof', short: 'Rof' },
    WOOD_WALL: { id: 16, color: '#6F4E37', solid: true, name: 'Wood Wall', short: 'W.Wal' },
    WOOD_RAIL: { id: 17, color: '#A0522D', solid: true, name: 'Wood Rail', short: 'W.Ral' }
};

const ID_TO_TILE = Object.values(TILES).reduce((acc, t) => { acc[t.id] = t; return acc; }, {});

const BLUEPRINTS = [
    { name: "Stone Tower", structure: [{x:0, y:0, id: TILES.TOWER_BASE_STONE.id}], cost: { [TILES.GREY.id]: 4, [TILES.WOOD.id]: 1 } },
    { name: "Iron Tower", structure: [{x:0, y:0, id: TILES.TOWER_BASE_IRON.id}], cost: { [TILES.GREY.id]: 1, [TILES.IRON.id]: 3, [TILES.WOOD.id]: 1 } },
    { name: "Gold Tower", structure: [{x:0, y:0, id: TILES.TOWER_BASE_GOLD.id}], cost: { [TILES.GREY.id]: 1, [TILES.GOLD.id]: 3, [TILES.WOOD.id]: 1 } },
    { name: "Stone Wall", structure: [{x:0, y:0, id: TILES.WALL.id}], cost: { [TILES.GREY.id]: 2 } },
    { name: "Wood Wall", structure: [{x:0, y:0, id: TILES.WOOD_WALL.id}], cost: { [TILES.WOOD.id]: 2 } },
    { name: "Bridge Block", structure: [{x:0, y:0, id: TILES.GREY.id}], cost: { [TILES.GREY.id]: 1, [TILES.WOOD.id]: 1 }, special: 'bridge' },
    { name: "Road Segment", structure: [{x:0, y:0, id: TILES.GREY.id}], cost: { [TILES.GREY.id]: 1 } }
];

// --- UTILS ---
function toggleBlueprints() {
    const menu = document.getElementById('blueprint-menu');
    menu.style.display = menu.style.display === 'grid' ? 'none' : 'grid';
}

class Utils {
    static hash(x, y, seed) {
        let h = seed + x * 374761393 + y * 668265263;
        h = (h ^ (h >> 13)) * 1274126177;
        return h ^ (h >> 16);
    }
    static noise(x, y, seed) {
        const s = Utils.hash(Math.floor(x), Math.floor(y), seed);
        return (s & 0xFFFFFFFF) / 0xFFFFFFFF; 
    }
    static getBiome(x, y, seed) {
        const scale = 0.05;
        const n = Math.sin(x * scale + seed) + Math.cos(y * scale + seed) * 0.5 + (Utils.noise(x, y, seed) * 0.2);
        if (n < -0.2) return TILES.WATER.id;
        if (n < -0.1) return TILES.SAND.id;
        return TILES.GRASS.id;
    }
    static distance(e1, e2) { return Math.sqrt((e1.x - e2.x)**2 + (e1.y - e2.y)**2); }
}

// --- ENGINE CORE ---

class InputHandler {
    constructor() {
        this.keys = {};
        this.mouse = { x: 0, y: 0, left: false, right: false, clickedLeft: false, clickedRight: false };
        this.wheel = 0;

        window.addEventListener('keydown', e => {
            this.keys[e.key.toLowerCase()] = true;
            if(e.key.toLowerCase() === 'escape') document.getElementById('blueprint-menu').style.display = 'none';
            if(e.key.toLowerCase() === 'b') toggleBlueprints();
        });
        window.addEventListener('keyup', e => this.keys[e.key.toLowerCase()] = false);
        window.addEventListener('mousemove', e => { this.mouse.x = e.clientX; this.mouse.y = e.clientY; });
        window.addEventListener('mousedown', e => {
            if(e.target.tagName !== 'CANVAS') return;
            if(e.button === 0) { this.mouse.left = true; this.mouse.clickedLeft = true; }
            if(e.button === 2) { this.mouse.right = true; this.mouse.clickedRight = true; }
        });
        window.addEventListener('mouseup', e => { this.mouse.left = false; this.mouse.right = false; });
        window.addEventListener('contextmenu', e => e.preventDefault());
        window.addEventListener('wheel', e => { this.wheel += e.deltaY; e.preventDefault(); }, { passive: false });
    }

    flush() {
        this.mouse.clickedLeft = false;
        this.mouse.clickedRight = false;
        this.wheel = 0;
    }
}

class Particle {
    constructor(x, y, color, dx, dy, life) {
        this.x = x; this.y = y; this.color = color;
        this.dx = dx; this.dy = dy; 
        this.life = life; this.maxLife = life;
    }
    update() { this.x += this.dx; this.y += this.dy; this.life--; }
    draw(ctx, camX, camY) {
        ctx.globalAlpha = Math.max(0, this.life / this.maxLife);
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x - camX, this.y - camY, 4, 4);
        ctx.globalAlpha = 1.0;
    }
}

class World {
    constructor(seed) {
        this.seed = seed || Math.floor(Math.random() * 10000);
        this.modifiedTiles = {}; 
    }
    getKey(x, y) { return `${x},${y}`; }
    getTile(x, y) { return this.modifiedTiles[this.getKey(x, y)] !== undefined ? this.modifiedTiles[this.getKey(x, y)] : Utils.getBiome(x, y, this.seed); }
    setTile(x, y, id) { this.modifiedTiles[this.getKey(x, y)] = id; }
    isSolid(x, y) { return ID_TO_TILE[this.getTile(x, y)].solid; }
}

class Entity {
    constructor(x, y, type) {
        this.x = x; this.y = y; this.type = type;
        this.speed = CONFIG.PLAYER_SPEED_BASE;
        this.hp = 100;
        this.damageBuffer = 0;
        this.inventory = { [TILES.GREY.id]: 50, [TILES.BLACK.id]: 20, [TILES.GOLD.id]: 20, [TILES.IRON.id]: 50, [TILES.WOOD.id]: 20 };
        this.selectedTile = TILES.GREY.id;
    }
    
    move(dx, dy, world) {
        const half = (CONFIG.TILE_SIZE / 2) - 4; // Hitbox reduction
        const check = (tx, ty) => {
            if (world.isSolid(Math.floor((tx - half)/CONFIG.TILE_SIZE), Math.floor((ty - half)/CONFIG.TILE_SIZE))) return false;
            if (world.isSolid(Math.floor((tx + half)/CONFIG.TILE_SIZE), Math.floor((ty - half)/CONFIG.TILE_SIZE))) return false;
            if (world.isSolid(Math.floor((tx - half)/CONFIG.TILE_SIZE), Math.floor((ty + half)/CONFIG.TILE_SIZE))) return false;
            if (world.isSolid(Math.floor((tx + half)/CONFIG.TILE_SIZE), Math.floor((ty + half)/CONFIG.TILE_SIZE))) return false;
            return true;
        };
        
        if (check(this.x + dx, this.y)) this.x += dx;
        if (check(this.x, this.y + dy)) this.y += dy;

        const gx = Math.floor(this.x / CONFIG.TILE_SIZE);
        const gy = Math.floor(this.y / CONFIG.TILE_SIZE);
        this.speed = (world.getTile(gx, gy) === TILES.GREY.id) ? CONFIG.PLAYER_SPEED_ROAD : CONFIG.PLAYER_SPEED_BASE;
    }
}

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        window.addEventListener('resize', () => this.resize());

        this.input = new InputHandler();
        this.world = new World();
        this.player = new Entity(0, 0, 'player');
        const spawn = this.findSafeSpawn();
        this.player.x = spawn.x; this.player.y = spawn.y;

        this.npcs = [];
        this.loot = [];
        this.projectiles = [];
        this.particles = [];
        this.texts = [];
        this.cannons = []; 
        
        this.camera = { x: 0, y: 0 };
        this.zoom = 1;
        this.lastTime = 0;
        this.regenTimer = 0;
        this.godMode = false;
        this.activeBlueprint = null;
        
        // Cache DOM elements
        this.dom = {
            hp: document.getElementById('hp'),
            coords: document.getElementById('coords'),
            seed: document.getElementById('seed-disp'),
            invBar: document.getElementById('inventory-bar'),
            bpMenu: document.getElementById('blueprint-menu'),
            activeBp: document.getElementById('active-bp-display'),
            bpName: document.getElementById('current-bp-name')
        };
        
        this.dom.seed.innerText = this.world.seed;
        this.initUI();
        
        window.addEventListener('keyup', (e) => {
            if (e.key.toLowerCase() === 'g') {
                this.godMode = !this.godMode;
                this.showMessage(this.godMode ? "GOD MODE ON" : "GOD MODE OFF");
                this.updateUI(); // Refresh UI to update availability
            }
        });

        requestAnimationFrame(t => this.loop(t));
    }

    resize() { this.canvas.width = window.innerWidth; this.canvas.height = window.innerHeight; }

    showMessage(text) {
        const msg = document.getElementById('messages');
        msg.innerHTML = text;
        msg.style.opacity = 1;
        setTimeout(() => msg.style.opacity = 0, 2000);
    }

    initUI() {
        this.dom.invBar.innerHTML = ''; 
        const usable = [TILES.GREY, TILES.BLACK, TILES.IRON, TILES.GOLD, TILES.WOOD];
        usable.forEach((t) => {
            const slot = document.createElement('div');
            slot.className = 'slot';
            slot.innerHTML = `<div class="slot-color" style="background:${t.color}"></div><div class="short-name">${t.short}</div><div class="qty" id="qty-${t.id}">0</div>`;
            slot.onclick = () => {
                this.player.selectedTile = t.id;
                this.activeBlueprint = null;
                this.updateUI();
            };
            this.dom.invBar.appendChild(slot);
        });
        
        this.dom.bpMenu.innerHTML = '';
        BLUEPRINTS.forEach((bp, index) => {
            const div = document.createElement('div');
            div.className = 'bp-item';
            
            // Build cost string
            let costStr = "Free";
            if (bp.cost) {
                costStr = Object.entries(bp.cost)
                    .map(([id, qty]) => `${qty} ${ID_TO_TILE[id].short}`)
                    .join(', ');
            }
            
            div.innerHTML = `<div class="bp-name">${bp.name}</div><div class="bp-req">${costStr}</div>`;
            // Tooltip removed as per request
            
            div.onclick = () => { 
                // Check affordability before selecting
                if (div.classList.contains('disabled')) return;
                
                this.activeBlueprint = bp; 
                toggleBlueprints(); 
                this.updateUI(); 
            };
            this.dom.bpMenu.appendChild(div);
        });
        this.updateUI();
    }

    updateUI() {
        const slots = document.querySelectorAll('.slot');
        const usable = [TILES.GREY, TILES.BLACK, TILES.IRON, TILES.GOLD, TILES.WOOD];
        slots.forEach((s, i) => {
            const id = usable[i].id;
            s.classList.toggle('active', !this.activeBlueprint && id === this.player.selectedTile);
            const qtyEl = document.getElementById(`qty-${id}`);
            if(qtyEl) qtyEl.innerText = this.player.inventory[id];
        });

        // Update Blueprint Menu Availability
        const bpItems = this.dom.bpMenu.children;
        BLUEPRINTS.forEach((bp, i) => {
            const div = bpItems[i];
            let canAfford = true;
            if (bp.cost && !this.godMode) {
                for (const [id, qty] of Object.entries(bp.cost)) {
                    if ((this.player.inventory[id] || 0) < qty) {
                        canAfford = false;
                        break;
                    }
                }
            }
            
            if (canAfford) {
                div.classList.remove('disabled');
            } else {
                div.classList.add('disabled');
            }
        });

        if(this.activeBlueprint) {
            this.dom.activeBp.style.display = 'block';
            this.dom.bpName.innerText = this.activeBlueprint.name;
        } else {
            this.dom.activeBp.style.display = 'none';
        }
    }

    findSafeSpawn() {
        // Increased attempts and fallback scan
        for (let r = 0; r < 500; r++) {
            const x = (Math.random() - 0.5) * 2000;
            const y = (Math.random() - 0.5) * 2000;
            const gx = Math.floor(x/CONFIG.TILE_SIZE);
            const gy = Math.floor(y/CONFIG.TILE_SIZE);
            if (this.world.getTile(gx, gy) !== TILES.WATER.id) return {x, y};
        }
        
        // If random fails, spiral out from 0,0 until land is found
        let r = 0;
        while (r < 100) {
            for (let x = -r; x <= r; x++) {
                for (let y = -r; y <= r; y++) {
                    if (this.world.getTile(x, y) !== TILES.WATER.id) {
                        return {x: x*CONFIG.TILE_SIZE, y: y*CONFIG.TILE_SIZE};
                    }
                }
            }
            r++;
        }
        return {x: 0, y: 0};
    }

    // --- LOGIC ---
    
    handleInteraction() {
        if (!this.input.mouse.clickedLeft && !this.input.mouse.clickedRight) return;

        const mx = (this.input.mouse.x / this.zoom) + this.camera.x;
        const my = (this.input.mouse.y / this.zoom) + this.camera.y;
        const gx = Math.floor(mx / CONFIG.TILE_SIZE);
        const gy = Math.floor(my / CONFIG.TILE_SIZE);

        if (Utils.distance(this.player, {x: mx, y: my}) > CONFIG.BUILD_RANGE) return;

        if (this.input.mouse.clickedLeft) {
            const cannon = this.cannons.find(c => {
                const [cx, cy] = c.key.split(',').map(Number);
                return gx === cx && gy === cy;
            });
            if (cannon && this.player.selectedTile === TILES.IRON.id) {
                if (this.player.inventory[TILES.IRON.id] > 0 || this.godMode) {
                    if (!this.godMode) this.player.inventory[TILES.IRON.id]--;
                    cannon.ammo += 5;
                    this.spawnText(cannon.x, cannon.y, "+5 AMMO", "#00ffff");
                    this.updateUI();
                    return;
                }
            }

            const canAfford = (id, cost) => this.godMode || (this.player.inventory[id] || 0) >= cost;
            const consume = (id, cost) => { if(!this.godMode) this.player.inventory[id] -= cost; };

            if (this.activeBlueprint) {
                const costMap = this.activeBlueprint.cost || {};
                
                // --- SPECIAL CHECKS ---
                if (this.activeBlueprint.special === 'bridge') {
                    // Smart Bridge Check: Must target Water or existing Rail
                    const targetId = this.world.getTile(gx, gy);
                    if (targetId !== TILES.WATER.id && targetId !== TILES.WOOD_RAIL.id) {
                         this.spawnText(mx * this.zoom, my * this.zoom, "MUST BUILD ON WATER/RAIL", "#f00");
                         return;
                    }
                } else if (this.activeBlueprint.requiresWater) {
                    if (this.world.getTile(gx, gy) !== TILES.WATER.id) {
                         this.spawnText(mx * this.zoom, my * this.zoom, "MUST BUILD ON WATER", "#f00");
                         return;
                    }
                }

                let affordable = true;
                for (let [id, qty] of Object.entries(costMap)) {
                    if (!canAfford(id, qty)) affordable = false;
                }

                if (affordable) {
                    let built = false;
                    
                    // Identify if this is a Bridge Blueprint
                    const isBridgeBp = this.activeBlueprint.special === 'bridge' || this.activeBlueprint.requiresWater;

                    this.activeBlueprint.structure.forEach(part => {
                        // Allow overwriting Rails if we are building a bridge
                        const overwriteRail = this.activeBlueprint.special === 'bridge';
                        if (this.tryBuild(gx + part.x, gy + part.y, part.id, overwriteRail, isBridgeBp)) built = true;
                    });
                    
                    if (built) {
                        for (let [id, qty] of Object.entries(costMap)) consume(id, qty);
                        
                        // Smart Bridge Logic: Auto-place rails on water neighbors
                        if (this.activeBlueprint.special === 'bridge') {
                            const neighbors = [
                                {x:gx+1, y:gy}, {x:gx-1, y:gy},
                                {x:gx, y:gy+1}, {x:gx, y:gy-1}
                            ];
                            neighbors.forEach(n => {
                                if (this.world.getTile(n.x, n.y) === TILES.WATER.id) {
                                    this.world.setTile(n.x, n.y, TILES.WOOD_RAIL.id);
                                    this.spawnParticles(n.x * CONFIG.TILE_SIZE + 16, n.y * CONFIG.TILE_SIZE + 16, TILES.WOOD.color, 4);
                                }
                            });
                        }

                        this.updateUI();
                        this.recalcCannons();
                    }
                }
            } else {
                const id = this.player.selectedTile;
                if (canAfford(id, 1)) {
                    // Single tile placement is never a bridge operation
                    if (this.tryBuild(gx, gy, id, false, false)) {
                        consume(id, 1);
                        this.updateUI();
                        this.recalcCannons();
                    }
                }
            }
        } else if (this.input.mouse.clickedRight) {
            if (this.activeBlueprint) {
                this.activeBlueprint = null;
                this.updateUI();
            } else {
                let tx = gx, ty = gy;
                let tileId = this.world.getTile(gx, gy);
                
                // RULE 2: Wood elements cannot be destroyed individually
                if (tileId === TILES.WOOD_RAIL.id) {
                     this.spawnText(mx * this.zoom, my * this.zoom, "BREAK ROAD TO DEMOLISH", "#f00");
                     return;
                }

                if (!ID_TO_TILE[tileId].solid) {
                    let below = this.world.getTile(gx, gy + 1);
                    if ([12,14,15].includes(below)) { ty = gy + 1; tileId = below; }
                    else {
                        let below2 = this.world.getTile(gx, gy + 2);
                        if ([12,14,15].includes(below2)) { ty = gy + 2; tileId = below2; }
                    }
                }

                if (tileId !== TILES.GRASS.id && tileId !== TILES.WATER.id && tileId !== TILES.SAND.id) {
                    
                    // RULE 1: Bridge cannot be removed if occupied
                    // We must calculate ALL tiles that will be removed (The road + dependent rails)
                    const tilesToRemove = [{x: tx, y: ty}];

                    // Check for dependent rails that will collapse
                    if (tileId === TILES.GREY.id) {
                        const neighbors = [
                            {x:tx+1, y:ty}, {x:tx-1, y:ty},
                            {x:tx, y:ty+1}, {x:tx, y:ty-1}
                        ];
                        neighbors.forEach(n => {
                            if (this.world.getTile(n.x, n.y) === TILES.WOOD_RAIL.id) {
                                // Check if this rail has ANY OTHER grey neighbors besides the one we are breaking
                                const railNeighbors = [
                                    {x:n.x+1, y:n.y}, {x:n.x-1, y:n.y},
                                    {x:n.x, y:n.y+1}, {x:n.x, y:n.y-1}
                                ];
                                const support = railNeighbors.some(rn => 
                                    (rn.x !== tx || rn.y !== ty) && this.world.getTile(rn.x, rn.y) === TILES.GREY.id
                                );
                                if (!support) {
                                    tilesToRemove.push({x: n.x, y: n.y});
                                }
                            }
                        });
                    }

                    // Check Intersection against ALL entities
                    const allEntities = [this.player, ...this.npcs];
                    const isOccupied = tilesToRemove.some(t => {
                        const tileCenter = {
                            x: t.x * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE/2, 
                            y: t.y * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE/2
                        };
                        return allEntities.some(e => Utils.distance(e, tileCenter) < CONFIG.TILE_SIZE/1.5);
                    });

                    if (isOccupied) {
                        this.spawnText(mx * this.zoom, my * this.zoom, "CANNOT BREAK: OCCUPIED", "#f00");
                        return;
                    }

                    // --- PROCEED WITH DESTRUCTION ---

                    // Restore Water if the biome was originally water
                    const biome = Utils.getBiome(tx, ty, this.world.seed);
                    const restoreId = (biome === TILES.WATER.id) ? TILES.WATER.id : TILES.GRASS.id;

                    this.world.setTile(tx, ty, restoreId);
                    
                    if (!this.godMode) {
                        if ([12,14,15].includes(tileId)) {
                             this.player.inventory[TILES.GREY.id] += 4;
                             this.player.inventory[TILES.WOOD.id] += 1;
                        } else {
                             this.player.inventory[tileId]++;
                        }
                    }
                    this.spawnParticles(tx * CONFIG.TILE_SIZE + 16, ty * CONFIG.TILE_SIZE + 16, '#777', 5);
                    
                    // Collapse dependent rails (We already calculated them, but need to act now)
                    tilesToRemove.forEach(t => {
                        // Skip the main tile we just broke
                        if (t.x === tx && t.y === ty) return;
                        
                        // Collapse Rail
                        this.world.setTile(t.x, t.y, TILES.WATER.id);
                        this.spawnParticles(t.x * CONFIG.TILE_SIZE + 16, t.y * CONFIG.TILE_SIZE + 16, TILES.WOOD.color, 4);
                        if (!this.godMode) this.player.inventory[TILES.WOOD.id] += 1;
                    });

                    this.recalcCannons();
                    this.updateUI();
                }
            }
        }
    }

    tryBuild(gx, gy, id, allowRailOverwrite = false, isBridge = false) {
        const tx = gx * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE/2;
        const ty = gy * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE/2;
        
        const allEntities = [...this.npcs, this.player];
        for (let e of allEntities) {
            if (Utils.distance({x:tx, y:ty}, e) < CONFIG.TILE_SIZE/1.5) return false;
        }
        
        const current = this.world.getTile(gx, gy);
        if (current === id) return false;
        
        // STRICT RULE: Cannot build on Water unless it is part of a Bridge Blueprint
        if (current === TILES.WATER.id && !isBridge) return false;
        
        // Special case: Allow overwriting rails if building a bridge/road
        if (allowRailOverwrite && current === TILES.WOOD_RAIL.id) {
            this.world.setTile(gx, gy, id);
            return true;
        }

        if (ID_TO_TILE[current].solid && current !== TILES.WATER.id) return false;
        
        this.world.setTile(gx, gy, id);
        return true;
    }

    recalcCannons() {
        const range = 30;
        const px = Math.floor(this.player.x / CONFIG.TILE_SIZE);
        const py = Math.floor(this.player.y / CONFIG.TILE_SIZE);
        const newCannons = [];
        
        for (let y = py - range; y < py + range; y++) {
            for (let x = px - range; x < px + range; x++) {
                const id = this.world.getTile(x, y);
                if ([12, 14, 15].includes(id)) {
                    const key = `${x},${y}`;
                    let damage = (id===12)?20 : (id===14)?40 : 80;
                    const existing = this.cannons.find(c => c.key === key);
                    newCannons.push({
                        key, x: x*CONFIG.TILE_SIZE + CONFIG.TILE_SIZE/2, y: y*CONFIG.TILE_SIZE + CONFIG.TILE_SIZE/2,
                        damage, cooldown: existing ? existing.cooldown : 0, ammo: existing ? existing.ammo : 10, range: 300
                    });
                }
            }
        }
        this.cannons = newCannons;
    }

    spawnText(x, y, txt, col) { 
        this.texts.push({x, y, txt, col, life: 60, dy: -1}); 
    }
    
    spawnParticles(x, y, color, count) {
        for(let i=0; i<count; i++) {
            this.particles.push(new Particle(x, y, color, (Math.random()-0.5)*5, (Math.random()-0.5)*5, 30 + Math.random()*20));
        }
    }

    update(dt) {
        if (this.input.wheel !== 0) {
            this.zoom = Math.max(0.5, Math.min(this.zoom - this.input.wheel * 0.001, 3));
        }

        // Regen
        this.regenTimer += dt;
        if (this.regenTimer > 2000 && this.player.hp < 100) {
            this.player.hp = Math.min(100, this.player.hp + 5);
            this.spawnText(this.player.x, this.player.y - 20, "+5 HP", "#0f0");
            this.regenTimer = 0;
        }

        let dx = 0, dy = 0;
        if(this.input.keys['w'] || this.input.keys['arrowup']) dy = -1;
        if(this.input.keys['s'] || this.input.keys['arrowdown']) dy = 1;
        if(this.input.keys['a'] || this.input.keys['arrowleft']) dx = -1;
        if(this.input.keys['d'] || this.input.keys['arrowright']) dx = 1;
        
        if (dx || dy) {
            const len = Math.sqrt(dx*dx + dy*dy);
            this.player.move((dx/len)*this.player.speed, (dy/len)*this.player.speed, this.world);
        }

        const viewW = this.canvas.width / this.zoom;
        const viewH = this.canvas.height / this.zoom;
        this.camera.x = this.player.x - viewW/2;
        this.camera.y = this.player.y - viewH/2;

        this.handleInteraction();

        // NPCs
        if (this.npcs.length < CONFIG.MAX_NPCS && Math.random() < CONFIG.NPC_SPAWN_RATE) {
            const ang = Math.random() * 6.28;
            const dist = 600;
            const nx = this.player.x + Math.cos(ang)*dist;
            const ny = this.player.y + Math.sin(ang)*dist;
            
            // Validate spawn location is NOT water
            const ngx = Math.floor(nx / CONFIG.TILE_SIZE);
            const ngy = Math.floor(ny / CONFIG.TILE_SIZE);
            
            if (this.world.getTile(ngx, ngy) !== TILES.WATER.id) {
                this.npcs.push(new Entity(nx, ny, 'npc'));
            }
        }

        this.npcs.forEach(npc => {
            const ang = Math.atan2(this.player.y - npc.y, this.player.x - npc.x);
            npc.move(Math.cos(ang)*2, Math.sin(ang)*2, this.world);
            
            // Collision Player (With Damage Buffer)
            if (Utils.distance(npc, this.player) < CONFIG.TILE_SIZE) {
                if (!this.godMode) {
                    this.player.damageBuffer += 0.5; // Accumulate damage
                    if (this.player.damageBuffer >= 1) {
                        const dmg = Math.floor(this.player.damageBuffer);
                        this.player.hp -= dmg;
                        this.player.damageBuffer -= dmg;
                        if (Math.random() > 0.8) this.spawnParticles(this.player.x, this.player.y, '#f00', 2);
                    }
                }
                // Knockback
                if (dx||dy) {
                    npc.x += dx * 20; npc.y += dy * 20;
                    npc.hp -= 20;
                    this.spawnParticles(npc.x, npc.y, '#f00', 5);
                    this.spawnText(npc.x, npc.y, "20", "#fff");
                }
            }
        });
        
        // Cannons Fire
        this.cannons.forEach(c => {
            if (c.cooldown > 0) c.cooldown--;
            else if (c.ammo > 0) {
                let target = this.npcs.find(n => Utils.distance(c, n) < c.range);
                if (target) {
                    this.projectiles.push({x: c.x, y: c.y - CONFIG.TILE_SIZE, tx: target.x, ty: target.y, dmg: c.damage, active: true});
                    c.cooldown = 60;
                    this.spawnParticles(c.x, c.y - CONFIG.TILE_SIZE, '#aaa', 8);
                    if (!this.godMode) c.ammo--;
                }
            }
        });

        // Projectiles
        this.projectiles.forEach(p => {
            const ang = Math.atan2(p.ty - p.y, p.tx - p.x);
            p.x += Math.cos(ang) * 12; p.y += Math.sin(ang) * 12;
            
            this.npcs.forEach(n => {
                if (Utils.distance(p, n) < 16) {
                    p.active = false;
                    n.hp -= p.dmg;
                    this.spawnParticles(n.x, n.y, '#f00', 6);
                    this.spawnText(n.x, n.y, Math.floor(p.dmg), "#fff");
                }
            });
            if (Utils.distance(p, {x:p.tx, y:p.ty}) < 10) p.active = false;
        });

        // Cleanup
        this.npcs = this.npcs.filter(n => {
            if (n.hp <= 0) {
                // Weighted Drop Logic
                const roll = Math.random();
                let dropId = TILES.GREY.id;
                let qty = 5;

                if (roll < 0.10) { 
                    dropId = TILES.GOLD.id; qty = 2; // 10% Chance: Gold (Rare)
                } else if (roll < 0.40) { 
                    dropId = TILES.WOOD.id; qty = 5; // 30% Chance: Wood
                } else if (roll < 0.70) { 
                    dropId = TILES.IRON.id; qty = 5; // 30% Chance: Iron
                } else { 
                    dropId = TILES.GREY.id; qty = 8; // 30% Chance: Stone
                }

                this.loot.push({x: n.x, y: n.y, id: dropId, qty: qty, bob: Math.random()*100});
                this.spawnParticles(n.x, n.y, '#f00', 10);
                return false;
            }
            return true;
        });
        this.projectiles = this.projectiles.filter(p => p.active);
        
        // Update particles & texts
        this.particles.forEach(p => p.update());
        this.particles = this.particles.filter(p => p.life > 0);
        
        this.texts.forEach(t => { t.y += t.dy; t.life--; });
        this.texts = this.texts.filter(t => t.life > 0);

        // Loot
        this.loot = this.loot.filter(l => {
            if (Utils.distance(this.player, l) < 32) {
                this.player.inventory[l.id] = (this.player.inventory[l.id]||0) + l.qty;
                this.spawnText(this.player.x, this.player.y - 30, `+${l.qty} ${ID_TO_TILE[l.id].short}`, "#ff0");
                this.updateUI();
                return false;
            }
            return true;
        });

        this.dom.hp.innerText = Math.floor(this.player.hp);
        this.dom.coords.innerText = `${Math.floor(this.player.x/CONFIG.TILE_SIZE)}, ${Math.floor(this.player.y/CONFIG.TILE_SIZE)}`;
        
        if (this.player.hp <= 0) location.reload();
        
        this.input.flush();
    }

    drawHealth(e) {
        const w = 24, h = 4;
        const x = e.x - w/2, y = e.y - CONFIG.TILE_SIZE/2 - 8;
        this.ctx.fillStyle = '#300'; this.ctx.fillRect(x, y, w, h);
        this.ctx.fillStyle = '#0f0'; this.ctx.fillRect(x, y, w * (Math.max(0,e.hp)/100), h);
    }

    draw() {
        this.ctx.fillStyle = '#1a1a1a';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        this.ctx.save();
        this.ctx.scale(this.zoom, this.zoom);
        this.ctx.translate(-this.camera.x, -this.camera.y);

        const startCol = Math.floor(this.camera.x / CONFIG.TILE_SIZE);
        const endCol = startCol + (this.canvas.width / this.zoom / CONFIG.TILE_SIZE) + 1;
        const startRow = Math.floor(this.camera.y / CONFIG.TILE_SIZE);
        const endRow = startRow + (this.canvas.height / this.zoom / CONFIG.TILE_SIZE) + 1;

        // 1. Bucket Entities & Loot by Row for Z-Sorting
        const rowBuckets = {};
        const addToBucket = (obj, type) => {
            const r = Math.floor(obj.y / CONFIG.TILE_SIZE);
            if (!rowBuckets[r]) rowBuckets[r] = [];
            rowBuckets[r].push({ ...obj, _type: type, _orig: obj });
        };

        this.npcs.forEach(n => addToBucket(n, 'npc'));
        addToBucket(this.player, 'player');
        this.loot.forEach(l => addToBucket(l, 'loot'));

        // 2. PASS 1: GROUND (Draws flat tiles first to prevent clipping)
        for (let r = startRow - 2; r <= endRow; r++) {
            for (let c = startCol; c <= endCol; c++) {
                const id = this.world.getTile(c, r);
                const tile = ID_TO_TILE[id];
                if (!tile) continue;

                // Draw ONLY if it is a flat tile (Not solid, or is Water)
                if (!tile.solid || id === TILES.WATER.id) {
                    const tx = c * CONFIG.TILE_SIZE;
                    const ty = r * CONFIG.TILE_SIZE;
                    this.ctx.fillStyle = tile.color;
                    this.ctx.fillRect(tx, ty, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);
                }
            }
        }

        // 3. PASS 2: OBJECTS (Walls, Towers, Entities) - Sorted by Row
        for (let r = startRow - 2; r <= endRow; r++) { 
            // A. Draw Static Structures for this Row
            for (let c = startCol; c <= endCol; c++) {
                const id = this.world.getTile(c, r);
                const tile = ID_TO_TILE[id];
                if (!tile) continue;
                
                // Skip if it was already drawn in Ground pass (unless it's a structure)
                if (!tile.solid || id === TILES.WATER.id) continue;

                const tx = c * CONFIG.TILE_SIZE;
                const ty = r * CONFIG.TILE_SIZE;

                // Draw Base Block
                this.ctx.fillStyle = tile.color;
                this.ctx.fillRect(tx, ty, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);
                
                // Detailed Shadows
                this.ctx.fillStyle = 'rgba(0,0,0,0.5)';
                this.ctx.fillRect(tx + CONFIG.TILE_SIZE - 4, ty, 4, CONFIG.TILE_SIZE); 
                this.ctx.fillRect(tx, ty + CONFIG.TILE_SIZE - 4, CONFIG.TILE_SIZE, 4); 
                this.ctx.fillStyle = 'rgba(255,255,255,0.1)';
                this.ctx.fillRect(tx, ty, CONFIG.TILE_SIZE, 4); 
                this.ctx.fillRect(tx, ty, 4, CONFIG.TILE_SIZE); 

                // Borders
                this.ctx.lineWidth = 1;
                this.ctx.strokeStyle = 'rgba(0,0,0,0.5)';
                this.ctx.strokeRect(tx, ty, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);

                // Draw TALL STRUCTURES (Decorations)
                if ([12, 14, 15].includes(id)) {
                    // Check for Occlusion
                    let isOccluding = false;
                    for (let checkR = r - 2; checkR < r; checkR++) {
                        if (rowBuckets[checkR]) {
                            if (rowBuckets[checkR].some(e => Math.floor(e.x / CONFIG.TILE_SIZE) === c)) isOccluding = true;
                        }
                    }

                    this.ctx.globalAlpha = isOccluding ? 0.4 : 1.0;

                    // Barrel
                    this.ctx.fillStyle = (id===14 ? '#444' : id===15 ? '#ffd700' : '#777');
                    this.ctx.fillRect(tx, ty - CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);
                    this.ctx.strokeRect(tx, ty - CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);
                    
                    // Roof
                    this.ctx.fillStyle = '#5C3317';
                    this.ctx.beginPath();
                    this.ctx.moveTo(tx, ty - CONFIG.TILE_SIZE);
                    this.ctx.lineTo(tx + CONFIG.TILE_SIZE, ty - CONFIG.TILE_SIZE);
                    this.ctx.lineTo(tx + CONFIG.TILE_SIZE/2, ty - CONFIG.TILE_SIZE*2);
                    this.ctx.closePath();
                    this.ctx.fill();
                    this.ctx.stroke();

                    // Ammo
                    const cannon = this.cannons.find(can => can.key === `${c},${r}`);
                    if (cannon) {
                        this.ctx.fillStyle = cannon.ammo > 0 ? '#0ff' : '#f00';
                        this.ctx.font = '10px monospace';
                        this.ctx.fillText(cannon.ammo, tx + 10, ty + 20);
                    }
                    
                    this.ctx.globalAlpha = 1.0;
                }
            }

            // B. Draw Entities & Loot for this Row
            if (rowBuckets[r]) {
                rowBuckets[r].forEach(obj => {
                    if (obj._type === 'loot') {
                        const bob = Math.sin((Date.now()/200) + obj.bob) * 3;
                        this.ctx.fillStyle = ID_TO_TILE[obj.id].color;
                        this.ctx.fillRect(obj.x - 6, obj.y - 6 + bob, 12, 12);
                    } else {
                        // Player/NPC
                        this.ctx.fillStyle = obj._type === 'player' ? '#ff0000' : '#aa0000';
                        this.ctx.fillRect(obj.x - 16, obj.y - 16, 32, 32);
                        this.drawHealth(obj._orig); 
                    }
                });
            }
        }

        // Projectiles (Always on top)
        this.ctx.fillStyle = '#fff';
        this.projectiles.forEach(p => {
            this.ctx.beginPath();
            this.ctx.arc(p.x, p.y, 4, 0, 6.28);
            this.ctx.fill();
        });

        this.particles.forEach(p => p.draw(this.ctx, 0, 0)); 

        // Ghost Blueprint
        if (this.activeBlueprint) {
            const mx = (this.input.mouse.x / this.zoom) + this.camera.x;
            const my = (this.input.mouse.y / this.zoom) + this.camera.y;
            const gx = Math.floor(mx / CONFIG.TILE_SIZE);
            const gy = Math.floor(my / CONFIG.TILE_SIZE);
            
            this.ctx.globalAlpha = 0.5;
            this.activeBlueprint.structure.forEach(part => {
                const tile = ID_TO_TILE[part.id];
                this.ctx.fillStyle = tile.color;
                this.ctx.fillRect((gx + part.x) * CONFIG.TILE_SIZE, (gy + part.y) * CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);
            });
            this.ctx.globalAlpha = 1.0;
            
            this.ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            this.ctx.beginPath();
            this.ctx.arc(this.player.x, this.player.y, CONFIG.BUILD_RANGE, 0, 6.28);
            this.ctx.stroke();
        }
        
        // Damage Text
        this.ctx.font = "bold 14px monospace";
        this.texts.forEach(t => {
            this.ctx.fillStyle = t.col;
            this.ctx.fillText(t.txt, t.x, t.y);
        });

        this.ctx.restore();
    }

    loop(timestamp) {
        const dt = timestamp - this.lastTime;
        this.lastTime = timestamp;
        this.update(dt);
        this.draw();
        requestAnimationFrame(t => this.loop(t));
    }
}

window.onload = () => new Game();
</script>
</body>
</html>