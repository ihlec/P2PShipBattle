<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Warfare Engine</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: 'Courier New', Courier, monospace;
            color: #eee;
            user-select: none;
        }
        canvas {
            display: block;
            image-rendering: pixelated; /* Crucial for the pixel art aesthetic */
        }
        #ui-layer {
            position: absolute;
            top: 10px;
            left: 10px;
            pointer-events: none;
        }
        .stat-box {
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border: 2px solid #555;
            margin-bottom: 5px;
            pointer-events: auto;
        }
        #inventory-bar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 8px;
            pointer-events: auto;
        }
        .slot {
            width: 50px;
            height: 50px;
            border: 2px solid #444;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
            position: relative;
            flex-direction: column;
        }
        .slot.active { border-color: #fff; box-shadow: 0 0 10px #fff; }
        .slot-color { width: 20px; height: 20px; border: 1px solid #000; margin-bottom: 2px; }
        .qty { position: absolute; bottom: 2px; right: 2px; font-weight: bold; font-size: 9px;}
        .short-name { font-size: 10px; color: #aaa; text-transform: uppercase; }
        
        #messages {
            position: absolute;
            top: 10%;
            width: 100%;
            text-align: center;
            font-size: 24px;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
            transition: opacity 1s;
        }

        /* Blueprint UI */
        #blueprint-menu {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #777;
            padding: 20px;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            pointer-events: auto;
            z-index: 100;
        }
        .bp-item {
            border: 1px solid #444;
            padding: 10px;
            text-align: center;
            cursor: pointer;
        }
        .bp-item:hover { background: #333; border-color: #fff; }
        .bp-name { font-weight: bold; margin-bottom: 5px; color: #ffd700; }
        .bp-req { font-size: 10px; color: #ccc; }
        .bp-btn {
            background: #444; color: #fff; border: 1px solid #fff; 
            padding: 5px 10px; cursor: pointer; margin-top: 5px;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="stat-box">
            <div>Health: <span id="hp">100</span></div>
            <div>Pos: <span id="coords">0, 0</span></div>
            <div>Seed: <span id="seed-disp"></span></div>
        </div>
        <div class="stat-box">
            <small>WASD: Move | Click: Place/Break</small>
            <div style="margin-top:5px;">
                <button class="bp-btn" onclick="toggleBlueprints()">Open Blueprints</button>
            </div>
            <div id="active-bp-display" style="color: #ffd700; font-size: 12px; display:none; margin-top:5px;">
                Active: <span id="current-bp-name"></span> (R-Click to Cancel)
            </div>
        </div>
    </div>

    <div id="messages"></div>

    <div id="blueprint-menu">
        <!-- Generated by JS -->
    </div>

    <div id="inventory-bar">
        <!-- Generated by JS -->
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
/**
 * SENIOR DEV NOTE:
 * strictly typed-object approach for Tile definitions.
 */

// --- CONFIGURATION ---
const TILE_SIZE = 32; 
const PLAYER_SPEED_BASE = 4;
const PLAYER_SPEED_ROAD = 8;
const NPC_SPAWN_RATE = 0.005;

// --- TILE DEFINITIONS ---
const TILES = {
    WATER: { id: 0, color: '#2b2b96', solid: true, name: 'Ocean', short: 'H2O' },
    GRASS: { id: 1, color: '#2d6e32', solid: false, name: 'Grass', short: 'Grs' },
    SAND:  { id: 2, color: '#c2b280', solid: false, name: 'Sand', short: 'Snd' },
    GREY:  { id: 3, color: '#777777', solid: false, name: 'Stone/Road', short: 'Stn' },
    // Updated Solids: Only Walls and Water are solid now. Others are decorative/walkable.
    BLACK: { id: 4, color: '#111111', solid: false, name: 'Obsidian', short: 'Obs' }, 
    IRON:  { id: 5, color: '#444444', solid: false, name: 'Iron Ammo', short: 'Irn' }, 
    GOLD_1: { id: 6, color: '#b8860b', solid: false, damage: 10, name: 'Dull Gold', short: 'Gd1' },
    GOLD_2: { id: 7, color: '#ffd700', solid: false, damage: 20, name: 'Gold', short: 'Gld' },
    GOLD_3: { id: 8, color: '#ffec8b', solid: false, damage: 40, name: 'Bright Gold', short: 'Gd3' },
    // NEW WALL LOGIC: ID 9
    WALL:  { id: 9, color: '#777777', solid: true, name: 'Wall', short: 'Wal' } 
};

const ID_TO_TILE = Object.values(TILES).reduce((acc, t) => { acc[t.id] = t; return acc; }, {});

// --- BLUEPRINT DEFINITIONS ---
const BLUEPRINTS = [
    {
        name: "Standard Cannon",
        // Pattern: 5 Gold Row, 2 Black below center
        structure: [
            {x:0, y:0, id: TILES.GOLD_2.id}, {x:1, y:0, id: TILES.GOLD_2.id}, {x:2, y:0, id: TILES.GOLD_2.id}, {x:3, y:0, id: TILES.GOLD_2.id}, {x:4, y:0, id: TILES.GOLD_2.id},
            {x:1, y:1, id: TILES.BLACK.id}, {x:2, y:1, id: TILES.BLACK.id}
        ]
    },
    {
        name: "Stone Wall",
        // Two stones on the SAME spot (Stacking)
        // By listing the same coord twice, the requirements calculation sees 2 STN needed
        // And the placement loop will trigger the "stacking" logic twice.
        structure: [
            {x:0, y:0, id: TILES.GREY.id},
            {x:0, y:0, id: TILES.GREY.id}
        ]
    },
    {
        name: "Road Segment",
        structure: [ {x:0, y:0, id: TILES.GREY.id} ]
    }
];

// --- GLOBAL HELPERS ---
function toggleBlueprints() {
    const menu = document.getElementById('blueprint-menu');
    menu.style.display = menu.style.display === 'grid' ? 'none' : 'grid';
}

// --- CORE SYSTEMS ---

class InputHandler {
    constructor() {
        this.keys = {};
        this.mouse = { x: 0, y: 0, left: false, right: false };
        this.wheel = 0;
        
        window.addEventListener('keydown', e => {
            this.keys[e.key.toLowerCase()] = true;
            if(e.key.toLowerCase() === 'escape') {
                document.getElementById('blueprint-menu').style.display = 'none';
            }
        });
        window.addEventListener('keyup', e => this.keys[e.key.toLowerCase()] = false);
        window.addEventListener('mousemove', e => {
            this.mouse.x = e.clientX;
            this.mouse.y = e.clientY;
        });
        window.addEventListener('mousedown', e => {
            if(e.target.tagName !== 'CANVAS') return;
            if(e.button === 0) this.mouse.left = true;
            if(e.button === 2) this.mouse.right = true;
        });
        window.addEventListener('mouseup', e => {
            this.mouse.left = false;
            this.mouse.right = false;
        });
        window.addEventListener('contextmenu', e => e.preventDefault());
        
        window.addEventListener('wheel', e => {
            this.wheel += e.deltaY;
            e.preventDefault();
        }, { passive: false });
    }
}

class Utils {
    static hash(x, y, seed) {
        let h = seed + x * 374761393 + y * 668265263;
        h = (h ^ (h >> 13)) * 1274126177;
        return h ^ (h >> 16);
    }

    static noise(x, y, seed) {
        const floorX = Math.floor(x);
        const floorY = Math.floor(y);
        const s = Utils.hash(floorX, floorY, seed);
        return (s & 0xFFFFFFFF) / 0xFFFFFFFF; 
    }

    static getBiome(x, y, seed) {
        const scale = 0.05;
        const n = Math.sin(x * scale + seed) + Math.cos(y * scale + seed) * 0.5 + (Utils.noise(x, y, seed) * 0.2);
        
        if (n < -0.2) return TILES.WATER.id;
        if (n < -0.1) return TILES.SAND.id;
        return TILES.GRASS.id;
    }

    static distance(e1, e2) {
        return Math.sqrt((e1.x - e2.x)**2 + (e1.y - e2.y)**2);
    }
}

class World {
    constructor(seed) {
        this.seed = seed || Math.floor(Math.random() * 10000);
        this.modifiedTiles = {}; 
    }

    getKey(x, y) { return `${x},${y}`; }

    getTile(x, y) {
        const key = this.getKey(x, y);
        if (this.modifiedTiles[key] !== undefined) return this.modifiedTiles[key];
        return Utils.getBiome(x, y, this.seed);
    }

    setTile(x, y, id) {
        this.modifiedTiles[this.getKey(x, y)] = id;
    }

    isSolid(x, y) {
        const id = this.getTile(x, y);
        const tile = ID_TO_TILE[id];
        // Wall is solid, Road (Grey) is not.
        return tile.solid;
    }

    isRoad(x, y) {
        const id = this.getTile(x, y);
        // Only standard Grey is a road. Wall (ID 9) is not.
        return id === TILES.GREY.id;
    }
}

class Particle {
    constructor(x, y, color, dx, dy, life) {
        this.x = x; this.y = y; this.color = color;
        this.dx = dx; this.dy = dy; this.life = life;
    }
    update() { this.x += this.dx; this.y += this.dy; this.life--; }
}

// NEW: Damage Text Class
class DamageText {
    constructor(x, y, amount, color) {
        this.x = x;
        this.y = y;
        this.amount = Math.floor(amount);
        this.color = color;
        this.life = 60; // 1 second @ 60fps
        this.dy = -1; // Float up speed
    }
    update() {
        this.y += this.dy;
        this.life--;
    }
}

class Projectile {
    constructor(x, y, targetX, targetY, damage) {
        this.x = x; this.y = y; this.speed = 12; 
        this.damage = damage; this.active = true;
        const angle = Math.atan2(targetY - y, targetX - x);
        this.dx = Math.cos(angle) * this.speed;
        this.dy = Math.sin(angle) * this.speed;
        this.size = 6;
    }
    update() { this.x += this.dx; this.y += this.dy; }
}

class Entity {
    constructor(x, y, type) {
        this.x = x; this.y = y;
        this.speed = PLAYER_SPEED_BASE;
        this.type = type; 
        this.hp = 100;
        this.dead = false;
        this.inventory = {
            [TILES.GREY.id]: 50,
            [TILES.BLACK.id]: 20,
            [TILES.GOLD_2.id]: 20,
            [TILES.IRON.id]: 50,
            [TILES.GOLD_1.id]: 10,
            [TILES.GOLD_3.id]: 10
        };
        this.selectedTile = TILES.GREY.id;
        // Buffer for continuous damage to prevent number spam
        this.damageBuffer = 0; 
    }

    move(dx, dy, world) {
        // AXIS-SEPARATED COLLISION
        // Allows sliding along walls instead of getting stuck
        
        // UNSTUCK LOGIC: If currently inside a solid block (glitch), allow movement to escape.
        const currGridX = Math.round(this.x / TILE_SIZE);
        const currGridY = Math.round(this.y / TILE_SIZE);
        const isStuck = world.isSolid(currGridX, currGridY);

        // 1. Check X Movement
        let nextX = this.x + dx;
        let gridX = Math.round(nextX / TILE_SIZE);
        let gridY = Math.round(this.y / TILE_SIZE);

        if (isStuck || !world.isSolid(gridX, gridY)) {
            this.x = nextX; 
        }

        // 2. Check Y Movement (Independently)
        let nextY = this.y + dy;
        gridX = Math.round(this.x / TILE_SIZE); // Update gridX based on valid x
        gridY = Math.round(nextY / TILE_SIZE);

        if (isStuck || !world.isSolid(gridX, gridY)) {
            this.y = nextY;
        }

        // 3. Update speed based on final tile
        const finalGridX = Math.round(this.x / TILE_SIZE);
        const finalGridY = Math.round(this.y / TILE_SIZE);
        if (world.isRoad(finalGridX, finalGridY)) this.speed = PLAYER_SPEED_ROAD;
        else this.speed = PLAYER_SPEED_BASE;
    }
}

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        window.addEventListener('resize', () => this.resize());

        this.input = new InputHandler();
        this.world = new World();
        const spawn = this.findSafeSpawn();
        this.player = new Entity(spawn.x, spawn.y, 'player');

        this.npcs = [];
        this.projectiles = [];
        this.particles = [];
        this.damageTexts = []; // New array for floating text
        this.camera = { x: 0, y: 0 };
        this.zoom = 1; 
        
        this.cannons = []; 
        this.lastTime = 0;
        this.regenTimer = 0;
        this.godMode = false;
        
        // Blueprint State
        this.activeBlueprint = null;

        window.addEventListener('keyup', (e) => {
            if (e.key.toLowerCase() === 'g') {
                this.godMode = !this.godMode;
                const msg = document.getElementById('messages');
                msg.innerHTML = this.godMode ? "GOD MODE: ENABLED" : "GOD MODE: DISABLED";
                msg.style.opacity = 1;
                setTimeout(() => msg.style.opacity = 0, 2000);
            }
        });

        this.initUI();
        this.loop(0);
    }

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
    }

    initUI() {
        const bar = document.getElementById('inventory-bar');
        bar.innerHTML = ''; // Clear prev
        const usable = [TILES.GREY, TILES.BLACK, TILES.IRON, TILES.GOLD_1, TILES.GOLD_2, TILES.GOLD_3];
        
        usable.forEach((t) => {
            const slot = document.createElement('div');
            slot.className = 'slot';
            slot.innerHTML = `
                <div class="slot-color" style="background:${t.color}"></div>
                <div class="short-name">${t.short}</div>
                <div class="qty" id="qty-${t.id}">0</div>
            `;
            slot.onclick = () => {
                this.player.selectedTile = t.id;
                this.activeBlueprint = null; // Clear BP when selecting item
                this.updateUIHighlight();
                this.updateBPDisplay();
            };
            bar.appendChild(slot);
        });
        
        // Init Blueprint Menu
        const menu = document.getElementById('blueprint-menu');
        menu.innerHTML = '';
        BLUEPRINTS.forEach(bp => {
            const div = document.createElement('div');
            div.className = 'bp-item';
            
            // Calculate Requirements
            const reqs = {};
            bp.structure.forEach(part => {
                const t = ID_TO_TILE[part.id];
                if(!reqs[t.short]) reqs[t.short] = 0;
                reqs[t.short]++;
            });
            const reqStr = Object.entries(reqs).map(([k, v]) => `${v} ${k}`).join(', ');

            div.innerHTML = `
                <div class="bp-name">${bp.name}</div>
                <div class="bp-req">Req: ${reqStr}</div>
            `;
            div.onclick = () => {
                this.activeBlueprint = bp;
                toggleBlueprints(); // Close menu
                this.updateBPDisplay();
            };
            menu.appendChild(div);
        });

        this.updateUIHighlight();
    }

    updateBPDisplay() {
        const disp = document.getElementById('active-bp-display');
        const nameSpan = document.getElementById('current-bp-name');
        if(this.activeBlueprint) {
            disp.style.display = 'block';
            nameSpan.innerText = this.activeBlueprint.name;
        } else {
            disp.style.display = 'none';
        }
    }

    findSafeSpawn() {
        let radius = 0;
        while (radius < 500) {
            for (let x = -radius; x <= radius; x++) {
                for (let y = -radius; y <= radius; y++) {
                    if (Math.abs(x) !== radius && Math.abs(y) !== radius) continue;
                    
                    // Center check
                    if (this.world.getTile(x, y) === TILES.WATER.id) continue;
                    
                    // Neighbor Check (Must be inland)
                    let safe = true;
                    for(let dx=-1; dx<=1; dx++) {
                        for(let dy=-1; dy<=1; dy++) {
                            if(this.world.getTile(x+dx, y+dy) === TILES.WATER.id) {
                                safe = false;
                                break;
                            }
                        }
                        if(!safe) break;
                    }
                    
                    if(safe) {
                        return { x: (x * TILE_SIZE) + (TILE_SIZE / 2), y: (y * TILE_SIZE) + (TILE_SIZE / 2) };
                    }
                }
            }
            radius++;
        }
        return { x: 0, y: 0 }; 
    }

    updateUIHighlight() {
        const slots = document.querySelectorAll('.slot');
        const usable = [TILES.GREY, TILES.BLACK, TILES.IRON, TILES.GOLD_1, TILES.GOLD_2, TILES.GOLD_3];
        slots.forEach((s, i) => {
            if(!this.activeBlueprint && usable[i].id === this.player.selectedTile) s.classList.add('active');
            else s.classList.remove('active');
        });
    }

    scanForCannons() {
        this.cannons = []; 
        const px = Math.floor(this.player.x / TILE_SIZE);
        const py = Math.floor(this.player.y / TILE_SIZE);
        const radius = 20; 

        for(let y = py - radius; y < py + radius; y++) {
            for(let x = px - radius; x < px + radius; x++) {
                // Check 5 horizontal golds
                let damageAccumulator = 0;
                let validGold = true;
                let firstGoldType = -1;

                for(let k=0; k<5; k++) {
                    const tid = this.world.getTile(x+k, y);
                    const tile = ID_TO_TILE[tid];
                    if(!tile || !tile.name.includes('Gold')) { validGold = false; break; }
                    if (firstGoldType === -1) firstGoldType = tid;
                    else if (tid !== firstGoldType) { validGold = false; break; }
                    damageAccumulator += tile.damage || 0;
                }

                if(validGold) {
                    const b1 = this.world.getTile(x+1, y+1);
                    const b2 = this.world.getTile(x+2, y+1);
                    if(b1 === TILES.BLACK.id && b2 === TILES.BLACK.id) {
                        this.cannons.push({
                            x: (x + 2) * TILE_SIZE,
                            y: y * TILE_SIZE,
                            damage: damageAccumulator / 5,
                            cooldown: 0,
                            range: 300
                        });
                    }
                }
            }
        }
    }

    spawnNPC() {
        const angle = Math.random() * Math.PI * 2;
        const dist = 600;
        const nx = this.player.x + Math.cos(angle) * dist;
        const ny = this.player.y + Math.sin(angle) * dist;
        const gx = Math.floor(nx / TILE_SIZE);
        const gy = Math.floor(ny / TILE_SIZE);
        if (!this.world.isSolid(gx, gy) && this.world.getTile(gx, gy) !== TILES.WATER.id) {
             this.npcs.push(new Entity(nx, ny, 'npc'));
        }
    }

    // Logic to handle tile placement with stacking
    smartPlaceTile(gx, gy, id, isBlueprint = false) {
        const currentId = this.world.getTile(gx, gy);
        
        // Definition of "Occupied": Any tile that isn't natural ground (Water/Grass/Sand)
        // IDs: 0=Water, 1=Grass, 2=Sand. All constructed blocks are > 2.
        const isOccupied = currentId > 2;

        if (isBlueprint) {
            // --- BLUEPRINT LOGIC (Privileged) ---
            
            // Stacking Logic: Stone on Stone -> Wall
            // This enables the "Stone Wall" blueprint to function by stacking 2 stones.
            if (id === TILES.GREY.id && currentId === TILES.GREY.id) {
                this.world.setTile(gx, gy, TILES.WALL.id);
                return;
            }

            // Blueprints can overwrite existing blocks if needed
            if (id !== currentId) {
                 this.world.setTile(gx, gy, id);
            }
        } else {
            // --- MANUAL LOGIC (Restricted) ---
            
            // Rule: "Two blocks cannot be put into the same spot"
            if (isOccupied) {
                return; // Block placement
            }

            // Standard placement on empty ground
            if (id !== currentId) {
                 this.world.setTile(gx, gy, id);
            }
        }
    }

    spawnDamageText(x, y, amount, color) {
        this.damageTexts.push(new DamageText(x, y, amount, color));
    }

    update(dt) {
        if (this.input.wheel !== 0) {
            const zoomSpeed = 0.001;
            this.zoom -= this.input.wheel * zoomSpeed;
            this.zoom = Math.max(0.5, Math.min(this.zoom, 3));
            this.input.wheel = 0;
        }

        this.regenTimer += dt;
        // BALANCE FIX: Player recovery lower (1 HP every 2 seconds instead of 2 HP every 1 second)
        // Previous: > 1000ms, +2 HP. (2.0 HP/s)
        // New:      > 2000ms, +1 HP. (0.5 HP/s)
        if (this.regenTimer > 2000) {
            // ONLY Player regenerates. NPCs do not.
            if (this.player.hp < 100) this.player.hp = Math.min(100, this.player.hp + 1);
            this.regenTimer = 0;
        }

        let dx = 0; let dy = 0;
        let currentSpeed = 0;
        if(this.input.keys['w'] || this.input.keys['arrowup']) dy = -1;
        if(this.input.keys['s'] || this.input.keys['arrowdown']) dy = 1;
        if(this.input.keys['a'] || this.input.keys['arrowleft']) dx = -1;
        if(this.input.keys['d'] || this.input.keys['arrowright']) dx = 1;

        if(dx !== 0 || dy !== 0) {
            const len = Math.sqrt(dx*dx + dy*dy);
            dx = (dx/len) * this.player.speed;
            dy = (dy/len) * this.player.speed;
            currentSpeed = this.player.speed;
            this.player.move(dx, dy, this.world);
        }

        const viewW = this.canvas.width / this.zoom;
        const viewH = this.canvas.height / this.zoom;
        this.camera.x = this.player.x - viewW / 2;
        this.camera.y = this.player.y - viewH / 2;

        // Interaction
        if(this.input.mouse.left || this.input.mouse.right) {
            const mx = (this.input.mouse.x / this.zoom) + this.camera.x;
            const my = (this.input.mouse.y / this.zoom) + this.camera.y;
            const gx = Math.floor(mx / TILE_SIZE);
            const gy = Math.floor(my / TILE_SIZE);

            if(this.input.mouse.left) {
                // If Blueprint Active
                if(this.activeBlueprint) {
                    // Check Cost
                    let canBuild = true;
                    // Count needs
                    const needs = {};
                    this.activeBlueprint.structure.forEach(part => {
                        const pid = part.id;
                        if(!needs[pid]) needs[pid] = 0;
                        needs[pid]++;
                    });
                    
                    // Verify inventory
                    for(const [pid, count] of Object.entries(needs)) {
                        if((this.player.inventory[pid] || 0) < count) canBuild = false;
                    }

                    if(canBuild) {
                        // Deduct and Place
                        for(const [pid, count] of Object.entries(needs)) {
                            this.player.inventory[pid] -= count;
                        }
                        this.activeBlueprint.structure.forEach(part => {
                            // PASS TRUE for Blueprint Mode
                            this.smartPlaceTile(gx + part.x, gy + part.y, part.id, true);
                        });
                        this.scanForCannons();
                        this.input.mouse.left = false; 
                    }
                } 
                // Normal Placement
                else {
                    const toPlace = this.player.selectedTile;
                    if(this.player.inventory[toPlace] > 0) {
                        const prevTile = this.world.getTile(gx, gy);
                        
                        // PASS FALSE for Manual Mode
                        this.smartPlaceTile(gx, gy, toPlace, false);
                        
                        // Only deduct if something actually changed (placement succeeded)
                        if (this.world.getTile(gx, gy) !== prevTile) {
                            this.player.inventory[toPlace]--;
                            this.scanForCannons(); 
                        }
                    }
                }
            } else {
                // Right click cancels blueprint
                if (this.activeBlueprint) {
                    this.activeBlueprint = null;
                    this.updateBPDisplay();
                    this.updateUIHighlight();
                } else {
                    // Break
                    const current = this.world.getTile(gx, gy);
                    
                    if (current === TILES.WALL.id) {
                        // Breaking Wall -> Becomes Road + Refunds 1 Stone
                        this.world.setTile(gx, gy, TILES.GREY.id);
                        this.player.inventory[TILES.GREY.id]++;
                        this.scanForCannons();
                    }
                    else if(current !== TILES.GRASS.id && current !== TILES.WATER.id && current !== TILES.SAND.id) {
                        // Normal Break
                        this.world.setTile(gx, gy, TILES.GRASS.id); 
                        if(!this.player.inventory[current]) this.player.inventory[current] = 0;
                        this.player.inventory[current]++;
                        this.scanForCannons();
                    }
                }
            }
        }

        if(Math.random() < NPC_SPAWN_RATE && this.npcs.length < 20) this.spawnNPC();

        this.npcs.forEach(npc => {
            if(npc.dead) return;
            const angle = Math.atan2(this.player.y - npc.y, this.player.x - npc.x);
            npc.speed = 2;
            const mx = Math.cos(angle) * npc.speed;
            const my = Math.sin(angle) * npc.speed;
            npc.move(mx, my, this.world);
            
            // SENIOR DEV FIX: 
            const playerHalf = TILE_SIZE / 2;
            const npcHalf = TILE_SIZE / 2;
            const touchThreshold = playerHalf + npcHalf + 0.5; 
            
            const collisionX = Math.abs(this.player.x - npc.x) < touchThreshold;
            const collisionY = Math.abs(this.player.y - npc.y) < touchThreshold;

            if(collisionX && collisionY) {
                const seconds = dt / 1000;

                // Player takes damage (Always happens on contact)
                if (!this.godMode) {
                     const damage = 5 * seconds;
                     this.player.hp -= damage;
                     this.player.damageBuffer += damage;
                     if(this.player.damageBuffer >= 1) {
                         const dmgInt = Math.floor(this.player.damageBuffer);
                         this.spawnDamageText(this.player.x, this.player.y - 20, dmgInt, '#ff0000');
                         this.player.damageBuffer -= dmgInt;
                     }
                }
                
                // NPC Damage Logic: PURE MOMENTUM + KNOCKBACK
                
                // Vector Check: Are we moving towards the enemy?
                const toEnemyX = npc.x - this.player.x;
                const toEnemyY = npc.y - this.player.y;
                // Dot product calculates the angle coherence. > 0 means "generally towards".
                const dotProduct = (dx * toEnemyX) + (dy * toEnemyY);

                // FIX: Only deal damage if speed > 1 AND we are moving towards the target
                if (currentSpeed > 1 && dotProduct > 0) { 
                    // Damage Formula: Pure Speed.
                    let impactDmg = currentSpeed * 20; 
                    if (this.godMode) impactDmg = 9999;

                    npc.hp -= impactDmg;
                    this.spawnDamageText(npc.x, npc.y - 20, impactDmg, '#ffffff'); 
                    
                    // Visual feedback
                    for(let i=0; i<5; i++) {
                        this.particles.push(new Particle(npc.x, npc.y, '#ff0000', (Math.random()-0.5)*8, (Math.random()-0.5)*8, 15));
                    }

                    // KNOCKBACK NPC (Push them away)
                    const knockbackDist = 40; 
                    const bx = npc.x - Math.cos(angle) * knockbackDist;
                    const by = npc.y - Math.sin(angle) * knockbackDist;
                    
                    // Check if knockback target is safe (don't push into walls)
                    const bgx = Math.round(bx / TILE_SIZE);
                    const bgy = Math.round(by / TILE_SIZE);
                    
                    if (!this.world.isSolid(bgx, bgy)) {
                        npc.x = bx;
                        npc.y = by;
                    }
                } 
                // If moving away (dotProduct <= 0), no damage is dealt.

                // Death Check
                if(npc.hp <= 0) {
                    npc.dead = true;
                    this.player.inventory[TILES.BLACK.id] += 2;
                    if(Math.random() > 0.5) this.player.inventory[TILES.GOLD_1.id]++;
                    if(Math.random() > 0.8) this.player.inventory[TILES.GOLD_2.id]++;
                    if(Math.random() > 0.95) this.player.inventory[TILES.GOLD_3.id]++;
                    this.player.inventory[TILES.IRON.id] += 5;
                }
            }
        });

        this.cannons.forEach(cannon => {
            if(cannon.cooldown > 0) cannon.cooldown--;
            else {
                if(this.player.inventory[TILES.IRON.id] > 0) {
                    let target = null;
                    let minDist = cannon.range;
                    this.npcs.forEach(npc => {
                        if(npc.dead) return;
                        const d = Utils.distance(cannon, npc);
                        if(d < minDist) { minDist = d; target = npc; }
                    });
                    if(target) {
                        this.player.inventory[TILES.IRON.id]--;
                        this.projectiles.push(new Projectile(cannon.x, cannon.y, target.x, target.y, cannon.damage));
                        cannon.cooldown = 60; 
                        for(let i=0; i<5; i++) {
                            this.particles.push(new Particle(cannon.x, cannon.y, '#aaa', (Math.random()-0.5)*4, (Math.random()-0.5)*4, 20));
                        }
                    }
                }
            }
        });

        this.projectiles.forEach(p => {
            p.update();
            this.npcs.forEach(npc => {
                if(!npc.dead && Utils.distance(p, npc) < TILE_SIZE) {
                    npc.hp -= p.damage;
                    this.spawnDamageText(npc.x, npc.y - 20, p.damage, '#ffffff');
                    p.active = false;
                    for(let i=0; i<3; i++) {
                        this.particles.push(new Particle(npc.x, npc.y, '#000', (Math.random()-0.5)*5, (Math.random()-0.5)*5, 30));
                    }
                    if(npc.hp <= 0) {
                        npc.dead = true;
                        this.player.inventory[TILES.BLACK.id] += 2;
                        if(Math.random() > 0.5) this.player.inventory[TILES.GOLD_1.id]++;
                        if(Math.random() > 0.8) this.player.inventory[TILES.GOLD_2.id]++;
                        if(Math.random() > 0.95) this.player.inventory[TILES.GOLD_3.id]++;
                         this.player.inventory[TILES.IRON.id] += 5;
                    }
                }
            });
            if(Utils.distance(p, {x:this.player.x, y:this.player.y}) > 1000) p.active = false; 
        });

        this.npcs = this.npcs.filter(n => !n.dead);
        this.projectiles = this.projectiles.filter(p => p.active);
        this.particles.forEach(p => p.update());
        this.particles = this.particles.filter(p => p.life > 0);
        
        this.damageTexts.forEach(d => d.update());
        this.damageTexts = this.damageTexts.filter(d => d.life > 0);

        document.getElementById('hp').innerText = Math.floor(this.player.hp);
        document.getElementById('coords').innerText = `${Math.floor(this.player.x/TILE_SIZE)}, ${Math.floor(this.player.y/TILE_SIZE)}`;
        document.getElementById('seed-disp').innerText = this.world.seed;
        
        Object.keys(this.player.inventory).forEach(k => {
            const el = document.getElementById(`qty-${k}`);
            if(el) el.innerText = this.player.inventory[k];
        });
        
        if(this.player.hp <= 0) {
            alert("You died. Reloading.");
            location.reload();
        }
    }

    // HELPER: Draw Health Bar
    drawHealthBar(entity) {
        const x = entity.x - this.camera.x;
        // Center of entity is entity.y. Bottom of entity is entity.y + 16.
        // We want bar inside, so we go up from bottom.
        // Bar Height = 4, Padding = 2.
        // Y = Center + HalfSize - BarHeight - Padding
        const y = (entity.y - this.camera.y) + (TILE_SIZE / 2) - 4 - 2; 
        
        const w = TILE_SIZE - 4; // Slight padding on sides
        const h = 4;

        // Background (Red)
        this.ctx.fillStyle = '#550000';
        this.ctx.fillRect(x - w/2, y, w, h);

        // Foreground (Green)
        const pct = Math.max(0, entity.hp / 100);
        this.ctx.fillStyle = '#00ff00';
        this.ctx.fillRect(x - w/2, y, w * pct, h);
    }

    draw() {
        this.ctx.fillStyle = '#1a1a1a';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        this.ctx.save();
        this.ctx.scale(this.zoom, this.zoom);
        this.ctx.imageSmoothingEnabled = false;

        const viewW = this.canvas.width / this.zoom;
        const viewH = this.canvas.height / this.zoom;
        const startCol = Math.floor(this.camera.x / TILE_SIZE);
        const endCol = startCol + (viewW / TILE_SIZE) + 1;
        const startRow = Math.floor(this.camera.y / TILE_SIZE);
        const endRow = startRow + (viewH / TILE_SIZE) + 1;

        for (let c = startCol; c <= endCol; c++) {
            for (let r = startRow; r <= endRow; r++) {
                const id = this.world.getTile(c, r);
                const tile = ID_TO_TILE[id];
                if (tile) {
                    this.ctx.fillStyle = tile.color;
                    this.ctx.fillRect(
                        Math.floor(c * TILE_SIZE - this.camera.x),
                        Math.floor(r * TILE_SIZE - this.camera.y),
                        TILE_SIZE,
                        TILE_SIZE
                    );
                    
                    // NEW VISUAL: Shadow for Walls
                    if (id === TILES.WALL.id) {
                         this.ctx.fillStyle = 'rgba(0,0,0,0.5)';
                         // Draw inner rect to fake height/shadow
                         this.ctx.fillRect(
                            Math.floor(c * TILE_SIZE - this.camera.x + 4),
                            Math.floor(r * TILE_SIZE - this.camera.y + 4),
                            TILE_SIZE - 8, TILE_SIZE - 8
                        );
                    }
                }
            }
        }

        // Draw Ghost Blueprint
        if (this.activeBlueprint) {
            const mx = (this.input.mouse.x / this.zoom) + this.camera.x;
            const my = (this.input.mouse.y / this.zoom) + this.camera.y;
            const gx = Math.floor(mx / TILE_SIZE);
            const gy = Math.floor(my / TILE_SIZE);
            
            this.ctx.globalAlpha = 0.5;
            this.activeBlueprint.structure.forEach(part => {
                const tile = ID_TO_TILE[part.id];
                this.ctx.fillStyle = tile.color;
                this.ctx.fillRect(
                    Math.floor((gx + part.x) * TILE_SIZE - this.camera.x),
                    Math.floor((gy + part.y) * TILE_SIZE - this.camera.y),
                    TILE_SIZE, TILE_SIZE
                );
            });
            this.ctx.globalAlpha = 1.0;
        }

        // Draw Player & Health
        this.ctx.fillStyle = '#ff0000'; 
        this.ctx.fillRect(
            this.player.x - this.camera.x - (TILE_SIZE/2),
            this.player.y - this.camera.y - (TILE_SIZE/2),
            TILE_SIZE, TILE_SIZE
        );
        this.drawHealthBar(this.player);

        // Draw NPCs & Health
        this.npcs.forEach(npc => {
            // FIX: Set Color to Black INSIDE the loop. 
            // Previous code set it outside, but drawHealthBar set it to Green, leaking to the next NPC.
            this.ctx.fillStyle = '#000'; 
            this.ctx.fillRect(
                npc.x - this.camera.x - (TILE_SIZE/2),
                npc.y - this.camera.y - (TILE_SIZE/2),
                TILE_SIZE, TILE_SIZE
            );
            this.drawHealthBar(npc);
        });

        this.ctx.fillStyle = '#fff';
        this.projectiles.forEach(p => {
            this.ctx.beginPath();
            this.ctx.arc(p.x - this.camera.x, p.y - this.camera.y, p.size, 0, Math.PI*2);
            this.ctx.fill();
        });

        this.particles.forEach(p => {
            this.ctx.fillStyle = p.color;
            this.ctx.fillRect(p.x - this.camera.x, p.y - this.camera.y, 4, 4);
        });
        
        // Draw Damage Texts
        this.ctx.font = "bold 14px 'Courier New'";
        this.damageTexts.forEach(d => {
            this.ctx.fillStyle = d.color;
            this.ctx.fillText(d.amount, d.x - this.camera.x, d.y - this.camera.y);
        });
        
        // REMOVED CANNON DEBUG BOX
        
        this.ctx.restore();
    }

    loop(timestamp) {
        const dt = timestamp - this.lastTime;
        this.lastTime = timestamp;
        this.update(dt);
        this.draw();
        requestAnimationFrame(t => this.loop(t));
    }
}

window.onload = () => {
    const msg = document.getElementById('messages');
    msg.innerHTML = "SURVIVE.<br><small>Click 'Open Blueprints' to build structures.</small>";
    setTimeout(() => msg.style.opacity = 0, 5000);
    new Game();
};

</script>
</body>
</html>