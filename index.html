<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Warfare Engine</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: 'Courier New', Courier, monospace;
            color: #eee;
            user-select: none;
        }
        canvas {
            display: block;
            image-rendering: pixelated; /* Crucial for the pixel art aesthetic */
        }
        #ui-layer {
            position: absolute;
            top: 10px;
            left: 10px;
            pointer-events: none;
        }
        .stat-box {
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border: 2px solid #555;
            margin-bottom: 5px;
            pointer-events: auto;
        }
        #inventory-bar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 8px;
            pointer-events: auto;
        }
        .slot {
            width: 50px;
            height: 50px;
            border: 2px solid #444;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
            position: relative;
            flex-direction: column;
        }
        .slot.active { border-color: #fff; box-shadow: 0 0 10px #fff; }
        .slot-color { width: 20px; height: 20px; border: 1px solid #000; margin-bottom: 2px; }
        .qty { position: absolute; bottom: 2px; right: 2px; font-weight: bold; font-size: 9px;}
        .short-name { font-size: 10px; color: #aaa; text-transform: uppercase; }
        
        #messages {
            position: absolute;
            top: 10%;
            width: 100%;
            text-align: center;
            font-size: 24px;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
            transition: opacity 1s;
        }

        /* Blueprint UI */
        #blueprint-menu {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #777;
            padding: 20px;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            pointer-events: auto;
            z-index: 100;
        }
        .bp-item {
            border: 1px solid #444;
            padding: 10px;
            text-align: center;
            cursor: pointer;
        }
        .bp-item:hover { background: #333; border-color: #fff; }
        .bp-name { font-weight: bold; margin-bottom: 5px; color: #ffd700; }
        .bp-req { font-size: 10px; color: #ccc; }
        .bp-btn {
            background: #444; color: #fff; border: 1px solid #fff; 
            padding: 5px 10px; cursor: pointer; margin-top: 5px;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="stat-box">
            <div>Health: <span id="hp">100</span></div>
            <div>Pos: <span id="coords">0, 0</span></div>
            <div>Seed: <span id="seed-disp"></span></div>
        </div>
        <div class="stat-box">
            <small>WASD: Move | Click: Place/Break</small>
            <div style="margin-top:5px;">
                <button class="bp-btn" onclick="toggleBlueprints()">Open Blueprints</button>
            </div>
            <div id="active-bp-display" style="color: #ffd700; font-size: 12px; display:none; margin-top:5px;">
                Active: <span id="current-bp-name"></span> (R-Click to Cancel)
            </div>
        </div>
    </div>

    <div id="messages"></div>

    <div id="blueprint-menu">
        <!-- Generated by JS -->
    </div>

    <div id="inventory-bar">
        <!-- Generated by JS -->
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
/**
 * SENIOR DEV NOTE:
 * strictly typed-object approach for Tile definitions.
 */

// --- CONFIGURATION ---
const TILE_SIZE = 32; 
const PLAYER_SPEED_BASE = 4;
const PLAYER_SPEED_ROAD = 8;
const NPC_SPAWN_RATE = 0.005;
const BUILD_RANGE = 200; // Restriction radius

// --- TILE DEFINITIONS ---
const TILES = {
    WATER: { id: 0, color: '#2b2b96', solid: true, name: 'Ocean', short: 'H2O' },
    GRASS: { id: 1, color: '#2d6e32', solid: false, name: 'Grass', short: 'Grs' },
    SAND:  { id: 2, color: '#c2b280', solid: false, name: 'Sand', short: 'Snd' },
    GREY:  { id: 3, color: '#777777', solid: false, name: 'Stone/Road', short: 'Stn' },
    // Updated Solids: Only Walls and Water are solid now. Others are decorative/walkable.
    BLACK: { id: 4, color: '#111111', solid: false, name: 'Obsidian', short: 'Obs' }, 
    IRON:  { id: 5, color: '#444444', solid: false, name: 'Iron', short: 'Irn' }, 
    GOLD_1: { id: 6, color: '#b8860b', solid: false, damage: 10, name: 'Dull Gold', short: 'Gd1' },
    GOLD_2: { id: 7, color: '#ffd700', solid: false, damage: 20, name: 'Gold', short: 'Gld' },
    GOLD_3: { id: 8, color: '#ffec8b', solid: false, damage: 40, name: 'Bright Gold', short: 'Gd3' },
    // NEW TILES
    WALL:  { id: 9, color: '#777777', solid: true, name: 'Wall', short: 'Wal' },
    WOOD:  { id: 10, color: '#8B4513', solid: false, name: 'Wood', short: 'Wod' },
    // Stone Block/Roof are now primarily visual helpers, not grid blockers
    STONE_BLOCK: { id: 11, color: '#777777', solid: false, name: 'Stone Block', short: 'StB' }, 
    
    // SPLIT BASES to store type in single tile
    TOWER_BASE_STONE: { id: 12, color: '#555555', solid: true, name: 'Stone Tower', short: 'T.St' },
    TOWER_BASE_IRON:  { id: 14, color: '#555555', solid: true, name: 'Iron Tower', short: 'T.Ir' },
    TOWER_BASE_GOLD:  { id: 15, color: '#555555', solid: true, name: 'Gold Tower', short: 'T.Gd' },
    
    ROOF: { id: 13, color: '#5C3317', solid: false, name: 'Roof', short: 'Rof' }
};

const ID_TO_TILE = Object.values(TILES).reduce((acc, t) => { acc[t.id] = t; return acc; }, {});

// --- BLUEPRINT DEFINITIONS ---
const BLUEPRINTS = [
    {
        name: "Stone Tower",
        // Structure: JUST THE BASE (1 Tile). Visuals are projected upwards.
        structure: [ {x:0, y:0, id: TILES.TOWER_BASE_STONE.id} ],
        // Cost: 1 Base Stone (Grey) + 3 Stone Barrel + 1 Wood Roof
        cost: { [TILES.GREY.id]: 4, [TILES.WOOD.id]: 1 }
    },
    {
        name: "Iron Tower",
        structure: [ {x:0, y:0, id: TILES.TOWER_BASE_IRON.id} ],
        cost: { [TILES.GREY.id]: 1, [TILES.IRON.id]: 3, [TILES.WOOD.id]: 1 }
    },
    {
        name: "Gold Tower",
        structure: [ {x:0, y:0, id: TILES.TOWER_BASE_GOLD.id} ],
        cost: { [TILES.GREY.id]: 1, [TILES.GOLD_2.id]: 3, [TILES.WOOD.id]: 1 }
    },
    {
        name: "Stone Wall",
        structure: [
            {x:0, y:0, id: TILES.GREY.id},
            {x:0, y:0, id: TILES.GREY.id}
        ]
    },
    {
        name: "Road Segment",
        structure: [ {x:0, y:0, id: TILES.GREY.id} ]
    }
];

// --- GLOBAL HELPERS ---
function toggleBlueprints() {
    const menu = document.getElementById('blueprint-menu');
    menu.style.display = menu.style.display === 'grid' ? 'none' : 'grid';
}

// --- CORE SYSTEMS ---

class InputHandler {
    constructor() {
        this.keys = {};
        this.mouse = { x: 0, y: 0, left: false, right: false };
        this.wheel = 0;
        
        window.addEventListener('keydown', e => {
            this.keys[e.key.toLowerCase()] = true;
            if(e.key.toLowerCase() === 'escape') {
                document.getElementById('blueprint-menu').style.display = 'none';
            }
        });
        window.addEventListener('keyup', e => this.keys[e.key.toLowerCase()] = false);
        window.addEventListener('mousemove', e => {
            this.mouse.x = e.clientX;
            this.mouse.y = e.clientY;
        });
        window.addEventListener('mousedown', e => {
            if(e.target.tagName !== 'CANVAS') return;
            if(e.button === 0) this.mouse.left = true;
            if(e.button === 2) this.mouse.right = true;
        });
        window.addEventListener('mouseup', e => {
            this.mouse.left = false;
            this.mouse.right = false;
        });
        window.addEventListener('contextmenu', e => e.preventDefault());
        
        window.addEventListener('wheel', e => {
            this.wheel += e.deltaY;
            e.preventDefault();
        }, { passive: false });
    }
}

class Utils {
    static hash(x, y, seed) {
        let h = seed + x * 374761393 + y * 668265263;
        h = (h ^ (h >> 13)) * 1274126177;
        return h ^ (h >> 16);
    }

    static noise(x, y, seed) {
        const floorX = Math.floor(x);
        const floorY = Math.floor(y);
        const s = Utils.hash(floorX, floorY, seed);
        return (s & 0xFFFFFFFF) / 0xFFFFFFFF; 
    }

    static getBiome(x, y, seed) {
        const scale = 0.05;
        const n = Math.sin(x * scale + seed) + Math.cos(y * scale + seed) * 0.5 + (Utils.noise(x, y, seed) * 0.2);
        
        if (n < -0.2) return TILES.WATER.id;
        if (n < -0.1) return TILES.SAND.id;
        return TILES.GRASS.id;
    }

    static distance(e1, e2) {
        return Math.sqrt((e1.x - e2.x)**2 + (e1.y - e2.y)**2);
    }
}

class World {
    constructor(seed) {
        this.seed = seed || Math.floor(Math.random() * 10000);
        this.modifiedTiles = {}; 
    }

    getKey(x, y) { return `${x},${y}`; }

    getTile(x, y) {
        const key = this.getKey(x, y);
        if (this.modifiedTiles[key] !== undefined) return this.modifiedTiles[key];
        return Utils.getBiome(x, y, this.seed);
    }

    setTile(x, y, id) {
        this.modifiedTiles[this.getKey(x, y)] = id;
    }

    isSolid(x, y) {
        const id = this.getTile(x, y);
        const tile = ID_TO_TILE[id];
        return tile.solid;
    }

    isRoad(x, y) {
        const id = this.getTile(x, y);
        // Only standard Grey is a road. Wall (ID 9) and Stone Block (ID 11) are not.
        return id === TILES.GREY.id;
    }
}

class Particle {
    constructor(x, y, color, dx, dy, life) {
        this.x = x; this.y = y; this.color = color;
        this.dx = dx; this.dy = dy; this.life = life;
    }
    update() { this.x += this.dx; this.y += this.dy; this.life--; }
}

class DamageText {
    constructor(x, y, amount, color) {
        this.x = x;
        this.y = y;
        this.amount = (typeof amount === 'number') ? Math.floor(amount) : amount;
        this.color = color;
        this.life = 60; 
        this.dy = -1; 
    }
    update() {
        this.y += this.dy;
        this.life--;
    }
}

// Loot Item Class
class Loot {
    constructor(x, y, id, qty) {
        this.x = x; 
        this.y = y;
        this.id = id;
        this.qty = qty;
        this.bobOffset = Math.random() * 100;
        this.pickedUp = false;
    }
}

class Projectile {
    constructor(x, y, targetX, targetY, damage) {
        this.x = x; this.y = y; this.speed = 12; 
        this.damage = damage; this.active = true;
        const angle = Math.atan2(targetY - y, targetX - x);
        this.dx = Math.cos(angle) * this.speed;
        this.dy = Math.sin(angle) * this.speed;
        this.size = 6;
    }
    update() { this.x += this.dx; this.y += this.dy; }
}

class Entity {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.speed = PLAYER_SPEED_BASE;
        this.type = type; 
        this.hp = 100;
        this.dead = false;
        this.inventory = {
            [TILES.GREY.id]: 50,
            [TILES.BLACK.id]: 20,
            [TILES.GOLD_2.id]: 20,
            [TILES.IRON.id]: 50,
            [TILES.GOLD_1.id]: 10,
            [TILES.GOLD_3.id]: 10,
            [TILES.WOOD.id]: 20
        };
        this.selectedTile = TILES.GREY.id;
        this.damageBuffer = 0; 
    }

    move(dx, dy, world) {
        const hitboxBuffer = 4;
        const halfSize = (TILE_SIZE / 2) - hitboxBuffer; 
        
        const isPositionSafe = (targetX, targetY) => {
            const left = targetX - halfSize;
            const right = targetX + halfSize;
            const top = targetY - halfSize;
            const bottom = targetY + halfSize;

            const points = [
                {x: left, y: top},
                {x: right, y: top},
                {x: left, y: bottom},
                {x: right, y: bottom}
            ];

            for (let p of points) {
                const gx = Math.floor(p.x / TILE_SIZE);
                const gy = Math.floor(p.y / TILE_SIZE);
                if (world.isSolid(gx, gy)) return false; 
            }
            return true; 
        };

        const centerGx = Math.floor(this.x / TILE_SIZE);
        const centerGy = Math.floor(this.y / TILE_SIZE);
        const currentlyStuck = world.isSolid(centerGx, centerGy);

        if (currentlyStuck || isPositionSafe(this.x + dx, this.y)) {
            this.x += dx;
        }

        if (currentlyStuck || isPositionSafe(this.x, this.y + dy)) {
            this.y += dy;
        }

        const finalGridX = Math.floor(this.x / TILE_SIZE);
        const finalGridY = Math.floor(this.y / TILE_SIZE);
        if (world.isRoad(finalGridX, finalGridY)) this.speed = PLAYER_SPEED_ROAD;
        else this.speed = PLAYER_SPEED_BASE;
    }
}

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        window.addEventListener('resize', () => this.resize());

        this.input = new InputHandler();
        this.world = new World();
        const spawn = this.findSafeSpawn();
        this.player = new Entity(spawn.x, spawn.y, 'player');

        this.npcs = [];
        this.lootItems = []; // Stores dropped items
        this.projectiles = [];
        this.particles = [];
        this.damageTexts = []; 
        this.camera = { x: 0, y: 0 };
        this.zoom = 1; 
        
        this.cannons = []; 
        this.lastTime = 0;
        this.regenTimer = 0;
        this.godMode = false;
        this.activeBlueprint = null;

        window.addEventListener('keyup', (e) => {
            if (e.key.toLowerCase() === 'g') {
                this.godMode = !this.godMode;
                const msg = document.getElementById('messages');
                msg.innerHTML = this.godMode ? "GOD MODE: ENABLED" : "GOD MODE: DISABLED";
                msg.style.opacity = 1;
                setTimeout(() => msg.style.opacity = 0, 2000);
            }
        });

        this.initUI();
        this.loop(0);
    }

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
    }

    initUI() {
        const bar = document.getElementById('inventory-bar');
        bar.innerHTML = ''; 
        const usable = [TILES.GREY, TILES.BLACK, TILES.IRON, TILES.GOLD_1, TILES.GOLD_2, TILES.GOLD_3, TILES.WOOD];
        
        usable.forEach((t) => {
            const slot = document.createElement('div');
            slot.className = 'slot';
            slot.innerHTML = `
                <div class="slot-color" style="background:${t.color}"></div>
                <div class="short-name">${t.short}</div>
                <div class="qty" id="qty-${t.id}">0</div>
            `;
            slot.onclick = () => {
                this.player.selectedTile = t.id;
                this.activeBlueprint = null; 
                this.updateUIHighlight();
                this.updateBPDisplay();
            };
            bar.appendChild(slot);
        });
        
        const menu = document.getElementById('blueprint-menu');
        menu.innerHTML = '';
        BLUEPRINTS.forEach(bp => {
            const div = document.createElement('div');
            div.className = 'bp-item';
            
            const reqs = {};
            if (bp.cost) {
                Object.entries(bp.cost).forEach(([id, qty]) => {
                    const t = ID_TO_TILE[id];
                    reqs[t.short] = qty;
                });
            } else {
                bp.structure.forEach(part => {
                    const t = ID_TO_TILE[part.id];
                    if(!reqs[t.short]) reqs[t.short] = 0;
                    reqs[t.short]++;
                });
            }
            
            const reqStr = Object.entries(reqs).map(([k, v]) => `${v} ${k}`).join(', ');

            div.innerHTML = `
                <div class="bp-name">${bp.name}</div>
                <div class="bp-req">Req: ${reqStr}</div>
            `;
            div.onclick = () => {
                this.activeBlueprint = bp;
                toggleBlueprints();
                this.updateBPDisplay();
            };
            menu.appendChild(div);
        });

        this.updateUIHighlight();
    }

    updateBPDisplay() {
        const disp = document.getElementById('active-bp-display');
        const nameSpan = document.getElementById('current-bp-name');
        if(this.activeBlueprint) {
            disp.style.display = 'block';
            nameSpan.innerText = this.activeBlueprint.name;
        } else {
            disp.style.display = 'none';
        }
    }

    findSafeSpawn() {
        let radius = 0;
        while (radius < 500) {
            for (let x = -radius; x <= radius; x++) {
                for (let y = -radius; y <= radius; y++) {
                    if (Math.abs(x) !== radius && Math.abs(y) !== radius) continue;
                    if (this.world.getTile(x, y) === TILES.WATER.id) continue;
                    
                    let safe = true;
                    for(let dx=-1; dx<=1; dx++) {
                        for(let dy=-1; dy<=1; dy++) {
                            if(this.world.getTile(x+dx, y+dy) === TILES.WATER.id) {
                                safe = false;
                                break;
                            }
                        }
                        if(!safe) break;
                    }
                    if(safe) return { x: (x * TILE_SIZE) + (TILE_SIZE / 2), y: (y * TILE_SIZE) + (TILE_SIZE / 2) };
                }
            }
            radius++;
        }
        return { x: 0, y: 0 }; 
    }

    updateUIHighlight() {
        const slots = document.querySelectorAll('.slot');
        const usable = [TILES.GREY, TILES.BLACK, TILES.IRON, TILES.GOLD_1, TILES.GOLD_2, TILES.GOLD_3, TILES.WOOD];
        slots.forEach((s, i) => {
            if(!this.activeBlueprint && usable[i].id === this.player.selectedTile) s.classList.add('active');
            else s.classList.remove('active');
        });
    }

    scanForCannons() {
        const px = Math.floor(this.player.x / TILE_SIZE);
        const py = Math.floor(this.player.y / TILE_SIZE);
        const radius = 20; 

        const nextCannons = [];
        for(let y = py - radius; y < py + radius; y++) {
            for(let x = px - radius; x < px + radius; x++) {
                const baseId = this.world.getTile(x, y);
                
                // TOWER LOGIC: Check Single Tile Type
                let damage = 0;
                if (baseId === TILES.TOWER_BASE_STONE.id) damage = 20;
                else if (baseId === TILES.TOWER_BASE_IRON.id) damage = 40;
                else if (baseId === TILES.TOWER_BASE_GOLD.id) damage = 80;

                if (damage > 0) {
                    const key = `${x},${y}`;
                    const prev = this.cannons.find(c => c.key === key);
                    nextCannons.push({
                        key: key,
                        x: (x * TILE_SIZE) + (TILE_SIZE/2),
                        y: ((y - 1) * TILE_SIZE) + (TILE_SIZE/2), // Fire from Virtual Middle
                        damage: damage,
                        cooldown: prev ? prev.cooldown : 0,
                        range: 300,
                        ammo: prev ? prev.ammo : 0
                    });
                }
            }
        }
        this.cannons = nextCannons;
    }

    spawnNPC() {
        const angle = Math.random() * Math.PI * 2;
        const dist = 600;
        const nx = this.player.x + Math.cos(angle) * dist;
        const ny = this.player.y + Math.sin(angle) * dist;
        const gx = Math.floor(nx / TILE_SIZE);
        const gy = Math.floor(ny / TILE_SIZE);
        if (!this.world.isSolid(gx, gy) && this.world.getTile(gx, gy) !== TILES.WATER.id) {
             this.npcs.push(new Entity(nx, ny, 'npc'));
        }
    }

    // Check if a specific tile grid coordinate is occupied by an entity
    isTileOccupiedByEntity(gx, gy) {
        // Tile Bounds
        const tx = gx * TILE_SIZE;
        const ty = gy * TILE_SIZE;
        const ts = TILE_SIZE;

        // Helper: Check intersection with an entity's hitbox
        // Entity hitbox is approx 24x24 (radius 12 from center)
        const checkOverlap = (e) => {
            const halfSize = 12; 
            const ex = e.x - halfSize;
            const ey = e.y - halfSize;
            const es = halfSize * 2;

            // AABB Intersection Test
            return (ex < tx + ts && ex + es > tx &&
                    ey < ty + ts && ey + es > ty);
        };

        // Check Player
        if (checkOverlap(this.player)) return true;

        // Check NPCs
        for(let npc of this.npcs) {
            if (checkOverlap(npc)) return true;
        }
        return false;
    }

    smartPlaceTile(gx, gy, id, isBlueprint = false) {
        const currentId = this.world.getTile(gx, gy);
        const isOccupied = currentId > 2;

        // RESTRICTION: Check entity intersection before placing
        if (this.isTileOccupiedByEntity(gx, gy)) return;

        if (isBlueprint) {
            if (id === TILES.GREY.id && currentId === TILES.GREY.id) {
                this.world.setTile(gx, gy, TILES.WALL.id);
                return;
            }
            
            // FIX: Prevent overwriting existing structures with blueprints
            if (isOccupied) return;

            if (id !== currentId) {
                 this.world.setTile(gx, gy, id);
            }
        } else {
            if (isOccupied) return; 
            if (id !== currentId) {
                 this.world.setTile(gx, gy, id);
            }
        }
    }

    spawnDamageText(x, y, amount, color) {
        this.damageTexts.push(new DamageText(x, y, amount, color));
    }

    update(dt) {
        if (this.input.wheel !== 0) {
            const zoomSpeed = 0.001;
            this.zoom -= this.input.wheel * zoomSpeed;
            this.zoom = Math.max(0.5, Math.min(this.zoom, 3));
            this.input.wheel = 0;
        }

        this.regenTimer += dt;
        if (this.regenTimer > 2000) {
            if (this.player.hp < 100) this.player.hp = Math.min(100, this.player.hp + 1);
            this.regenTimer = 0;
        }

        let dx = 0; let dy = 0;
        let currentSpeed = 0;
        if(this.input.keys['w'] || this.input.keys['arrowup']) dy = -1;
        if(this.input.keys['s'] || this.input.keys['arrowdown']) dy = 1;
        if(this.input.keys['a'] || this.input.keys['arrowleft']) dx = -1;
        if(this.input.keys['d'] || this.input.keys['arrowright']) dx = 1;

        if(dx !== 0 || dy !== 0) {
            const len = Math.sqrt(dx*dx + dy*dy);
            dx = (dx/len) * this.player.speed;
            dy = (dy/len) * this.player.speed;
            currentSpeed = this.player.speed;
            this.player.move(dx, dy, this.world);
        }

        const viewW = this.canvas.width / this.zoom;
        const viewH = this.canvas.height / this.zoom;
        this.camera.x = this.player.x - viewW / 2;
        this.camera.y = this.player.y - viewH / 2;

        // Interaction
        if(this.input.mouse.left || this.input.mouse.right) {
            const mx = (this.input.mouse.x / this.zoom) + this.camera.x;
            const my = (this.input.mouse.y / this.zoom) + this.camera.y;
            const gx = Math.floor(mx / TILE_SIZE);
            const gy = Math.floor(my / TILE_SIZE);

            const distToMouse = Math.sqrt(Math.pow(this.player.x - mx, 2) + Math.pow(this.player.y - my, 2));
            const inRange = distToMouse <= BUILD_RANGE;

            if (inRange) {
                if(this.input.mouse.left) {
                    // MANUAL CANNON RELOAD
                    if (this.player.selectedTile === TILES.IRON.id) {
                        const clickedCannon = this.cannons.find(c => {
                            const dc = Math.sqrt(Math.pow(c.x - mx, 2) + Math.pow(c.y - my, 2));
                            return dc < TILE_SIZE * 1.5;
                        });

                        if (clickedCannon) {
                            if (this.player.inventory[TILES.IRON.id] > 0 || this.godMode) {
                                if (!this.godMode) this.player.inventory[TILES.IRON.id]--;
                                clickedCannon.ammo += 5;
                                this.spawnDamageText(clickedCannon.x, clickedCannon.y, "+5 AMMO", "#00ffff");
                                this.input.mouse.left = false; 
                                return; 
                            }
                        }
                    }

                    if(this.activeBlueprint) {
                        let canBuild = true;
                        const needs = {};
                        if (this.activeBlueprint.cost) {
                            Object.entries(this.activeBlueprint.cost).forEach(([id, qty]) => {
                                needs[id] = qty;
                            });
                        } else {
                            this.activeBlueprint.structure.forEach(part => {
                                const pid = part.id;
                                if(!needs[pid]) needs[pid] = 0;
                                needs[pid]++;
                            });
                        }
                        
                        if (!this.godMode) {
                            for(const [pid, count] of Object.entries(needs)) {
                                if((this.player.inventory[pid] || 0) < count) canBuild = false;
                            }
                        }

                        if(canBuild) {
                            if (!this.godMode) {
                                for(const [pid, count] of Object.entries(needs)) {
                                    this.player.inventory[pid] -= count;
                                }
                            }
                            
                            this.activeBlueprint.structure.forEach(part => {
                                this.smartPlaceTile(gx + part.x, gy + part.y, part.id, true);
                            });
                            this.scanForCannons();
                            this.input.mouse.left = false; 
                        }
                    } 
                    else {
                        const toPlace = this.player.selectedTile;
                        if(this.godMode || this.player.inventory[toPlace] > 0) {
                            const prevTile = this.world.getTile(gx, gy);
                            this.smartPlaceTile(gx, gy, toPlace, false);
                            if (this.world.getTile(gx, gy) !== prevTile) {
                                if (!this.godMode) {
                                    this.player.inventory[toPlace]--;
                                }
                                this.scanForCannons(); 
                            }
                        }
                    }
                } else {
                    // RIGHT CLICK BREAK
                    if (this.activeBlueprint) {
                        this.activeBlueprint = null;
                        this.updateBPDisplay();
                        this.updateUIHighlight();
                    } else {
                        // TOWER DESTRUCTION LOGIC (Virtual Detection)
                        // Check if we clicked the Base, OR the virtual space above it (y+1 or y+2 relative to base)
                        
                        // Scan neighborhood for a base that "owns" this tile
                        let baseGx = gx;
                        let baseY = -1;
                        let foundTowerId = -1;

                        // 1. Direct Click on Base
                        let tid = this.world.getTile(gx, gy);
                        if (tid === TILES.TOWER_BASE_STONE.id || tid === TILES.TOWER_BASE_IRON.id || tid === TILES.TOWER_BASE_GOLD.id) {
                            baseY = gy;
                            foundTowerId = tid;
                        }
                        // 2. Clicked "Mid" (y-1 relative to base, so look at gy+1)
                        else {
                            let below = this.world.getTile(gx, gy + 1);
                            if (below === TILES.TOWER_BASE_STONE.id || below === TILES.TOWER_BASE_IRON.id || below === TILES.TOWER_BASE_GOLD.id) {
                                baseY = gy + 1;
                                foundTowerId = below;
                            } 
                            // 3. Clicked "Top" (y-2 relative to base, so look at gy+2)
                            else {
                                let below2 = this.world.getTile(gx, gy + 2);
                                if (below2 === TILES.TOWER_BASE_STONE.id || below2 === TILES.TOWER_BASE_IRON.id || below2 === TILES.TOWER_BASE_GOLD.id) {
                                    baseY = gy + 2;
                                    foundTowerId = below2;
                                }
                            }
                        }

                        if (foundTowerId !== -1) {
                            // Destroy Base Only (Upper parts are virtual)
                            this.world.setTile(baseGx, baseY, TILES.GRASS.id);

                            // Refund
                            if (!this.godMode) {
                                this.player.inventory[TILES.GREY.id] += 1; // Base Refund
                                this.player.inventory[TILES.WOOD.id] += 1; // Roof Refund
                                
                                if (foundTowerId === TILES.TOWER_BASE_STONE.id) this.player.inventory[TILES.GREY.id] += 3; 
                                else if (foundTowerId === TILES.TOWER_BASE_IRON.id) this.player.inventory[TILES.IRON.id] += 3;
                                else if (foundTowerId === TILES.TOWER_BASE_GOLD.id) this.player.inventory[TILES.GOLD_2.id] += 3;
                            }

                            this.scanForCannons();
                        } 
                        else {
                            // Normal Break Logic
                            const current = this.world.getTile(gx, gy);
                            
                            if (current === TILES.WALL.id) {
                                this.world.setTile(gx, gy, TILES.GREY.id);
                                this.player.inventory[TILES.GREY.id]++;
                                this.scanForCannons();
                            }
                            else if(current !== TILES.GRASS.id && current !== TILES.WATER.id && current !== TILES.SAND.id) {
                                this.world.setTile(gx, gy, TILES.GRASS.id); 
                                if(!this.player.inventory[current]) this.player.inventory[current] = 0;
                                this.player.inventory[current]++;
                                this.scanForCannons();
                            }
                        }
                    }
                }
            }
        }

        if(Math.random() < NPC_SPAWN_RATE && this.npcs.length < 20) this.spawnNPC();

        // LOOT PICKUP
        this.lootItems.forEach(item => {
            if (item.pickedUp) return;
            const d = Utils.distance(this.player, item);
            if (d < TILE_SIZE) {
                if(!this.player.inventory[item.id]) this.player.inventory[item.id] = 0;
                this.player.inventory[item.id] += item.qty;
                item.pickedUp = true;
                
                const tx = this.player.x + (Math.random() - 0.5) * 40;
                const ty = this.player.y - 40 + (Math.random() - 0.5) * 20;
                this.spawnDamageText(tx, ty, `+${item.qty} ${ID_TO_TILE[item.id].short}`, "#ffff00");
            }
        });
        this.lootItems = this.lootItems.filter(i => !i.pickedUp);

        this.npcs.forEach(npc => {
            if(npc.dead) return;
            const angle = Math.atan2(this.player.y - npc.y, this.player.x - npc.x);
            npc.speed = 2;
            const mx = Math.cos(angle) * npc.speed;
            const my = Math.sin(angle) * npc.speed;
            npc.move(mx, my, this.world);
            
            const playerHalf = TILE_SIZE / 2;
            const npcHalf = TILE_SIZE / 2;
            const touchThreshold = playerHalf + npcHalf + 0.5; 
            
            const collisionX = Math.abs(this.player.x - npc.x) < touchThreshold;
            const collisionY = Math.abs(this.player.y - npc.y) < touchThreshold;

            if(collisionX && collisionY) {
                const seconds = dt / 1000;

                if (!this.godMode) {
                     const damage = 5 * seconds;
                     this.player.hp -= damage;
                     this.player.damageBuffer += damage;
                     if(this.player.damageBuffer >= 1) {
                         const dmgInt = Math.floor(this.player.damageBuffer);
                         this.spawnDamageText(this.player.x, this.player.y - 20, dmgInt, '#ff0000');
                         this.player.damageBuffer -= dmgInt;
                     }
                }
                
                const toEnemyX = npc.x - this.player.x;
                const toEnemyY = npc.y - this.player.y;
                const dotProduct = (dx * toEnemyX) + (dy * toEnemyY);

                if (currentSpeed > 1 && dotProduct > 0) { 
                    let impactDmg = currentSpeed * 20; 
                    if (this.godMode) impactDmg = 9999;

                    npc.hp -= impactDmg;
                    this.spawnDamageText(npc.x, npc.y - 20, impactDmg, '#ffffff'); 
                    
                    for(let i=0; i<5; i++) {
                        this.particles.push(new Particle(npc.x, npc.y, '#ff0000', (Math.random()-0.5)*8, (Math.random()-0.5)*8, 15));
                    }

                    const knockbackDist = 40; 
                    const bx = npc.x - Math.cos(angle) * knockbackDist;
                    const by = npc.y - Math.sin(angle) * knockbackDist;
                    
                    const bgx = Math.round(bx / TILE_SIZE);
                    const bgy = Math.round(by / TILE_SIZE);
                    
                    if (!this.world.isSolid(bgx, bgy)) {
                        npc.x = bx;
                        npc.y = by;
                    }
                } 

                if(npc.hp <= 0) {
                    npc.dead = true;
                    const spread = 24;
                    this.lootItems.push(new Loot(npc.x + (Math.random()-0.5)*spread, npc.y + (Math.random()-0.5)*spread, TILES.BLACK.id, 2));
                    if(Math.random() > 0.5) this.lootItems.push(new Loot(npc.x + (Math.random()-0.5)*spread, npc.y + (Math.random()-0.5)*spread, TILES.GOLD_1.id, 1));
                    if(Math.random() > 0.8) this.lootItems.push(new Loot(npc.x + (Math.random()-0.5)*spread, npc.y + (Math.random()-0.5)*spread, TILES.GOLD_2.id, 1));
                    if(Math.random() > 0.95) this.lootItems.push(new Loot(npc.x + (Math.random()-0.5)*spread, npc.y + (Math.random()-0.5)*spread, TILES.GOLD_3.id, 1));
                    this.lootItems.push(new Loot(npc.x + (Math.random()-0.5)*spread, npc.y + (Math.random()-0.5)*spread, TILES.IRON.id, 5));
                }
            }
        });

        this.cannons.forEach(cannon => {
            if(cannon.cooldown > 0) cannon.cooldown--;
            else {
                if(cannon.ammo > 0) {
                    let target = null;
                    let minDist = cannon.range;
                    this.npcs.forEach(npc => {
                        if(npc.dead) return;
                        const d = Utils.distance(cannon, npc);
                        if(d < minDist) { minDist = d; target = npc; }
                    });
                    if(target) {
                        if (!this.godMode) cannon.ammo--;
                        
                        this.projectiles.push(new Projectile(cannon.x, cannon.y, target.x, target.y, cannon.damage));
                        cannon.cooldown = 60; 
                        for(let i=0; i<5; i++) {
                            this.particles.push(new Particle(cannon.x, cannon.y, '#aaa', (Math.random()-0.5)*4, (Math.random()-0.5)*4, 20));
                        }
                    }
                }
            }
        });

        this.projectiles.forEach(p => {
            p.update();
            this.npcs.forEach(npc => {
                if(!npc.dead && Utils.distance(p, npc) < TILE_SIZE) {
                    npc.hp -= p.damage;
                    this.spawnDamageText(npc.x, npc.y - 20, p.damage, '#ffffff');
                    p.active = false;
                    for(let i=0; i<3; i++) {
                        this.particles.push(new Particle(npc.x, npc.y, '#000', (Math.random()-0.5)*5, (Math.random()-0.5)*5, 30));
                    }
                    if(npc.hp <= 0) {
                        npc.dead = true;
                        const spread = 24;
                        this.lootItems.push(new Loot(npc.x + (Math.random()-0.5)*spread, npc.y + (Math.random()-0.5)*spread, TILES.BLACK.id, 2));
                        if(Math.random() > 0.5) this.lootItems.push(new Loot(npc.x + (Math.random()-0.5)*spread, npc.y + (Math.random()-0.5)*spread, TILES.GOLD_1.id, 1));
                        if(Math.random() > 0.8) this.lootItems.push(new Loot(npc.x + (Math.random()-0.5)*spread, npc.y + (Math.random()-0.5)*spread, TILES.GOLD_2.id, 1));
                        if(Math.random() > 0.95) this.lootItems.push(new Loot(npc.x + (Math.random()-0.5)*spread, npc.y + (Math.random()-0.5)*spread, TILES.GOLD_3.id, 1));
                        this.lootItems.push(new Loot(npc.x + (Math.random()-0.5)*spread, npc.y + (Math.random()-0.5)*spread, TILES.IRON.id, 5));
                    }
                }
            });
            if(Utils.distance(p, {x:this.player.x, y:this.player.y}) > 1000) p.active = false; 
        });

        this.npcs = this.npcs.filter(n => !n.dead);
        this.projectiles = this.projectiles.filter(p => p.active);
        this.particles.forEach(p => p.update());
        this.particles = this.particles.filter(p => p.life > 0);
        
        this.damageTexts.forEach(d => d.update());
        this.damageTexts = this.damageTexts.filter(d => d.life > 0);

        document.getElementById('hp').innerText = Math.floor(this.player.hp);
        document.getElementById('coords').innerText = `${Math.floor(this.player.x/TILE_SIZE)}, ${Math.floor(this.player.y/TILE_SIZE)}`;
        document.getElementById('seed-disp').innerText = this.world.seed;
        
        Object.keys(this.player.inventory).forEach(k => {
            const el = document.getElementById(`qty-${k}`);
            if(el) el.innerText = this.player.inventory[k];
        });
        
        if(this.player.hp <= 0) {
            alert("You died. Reloading.");
            location.reload();
        }
    }

    drawHealthBar(entity) {
        const x = entity.x - this.camera.x;
        const y = (entity.y - this.camera.y) + (TILE_SIZE / 2) - 4 - 2; 
        const w = TILE_SIZE - 4; 
        const h = 4;

        this.ctx.fillStyle = '#550000';
        this.ctx.fillRect(x - w/2, y, w, h);

        const pct = Math.max(0, entity.hp / 100);
        this.ctx.fillStyle = '#00ff00';
        this.ctx.fillRect(x - w/2, y, w * pct, h);
    }

    draw() {
        this.ctx.fillStyle = '#1a1a1a';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        this.ctx.save();
        this.ctx.scale(this.zoom, this.zoom);
        this.ctx.imageSmoothingEnabled = false;

        const viewW = this.canvas.width / this.zoom;
        const viewH = this.canvas.height / this.zoom;
        const startCol = Math.floor(this.camera.x / TILE_SIZE);
        const endCol = startCol + (viewW / TILE_SIZE) + 1;
        const startRow = Math.floor(this.camera.y / TILE_SIZE);
        const endRow = startRow + (viewH / TILE_SIZE) + 1;

        // PASS 1: Draw Ground & Standard Objects
        for (let c = startCol; c <= endCol; c++) {
            for (let r = startRow; r <= endRow; r++) {
                const id = this.world.getTile(c, r);
                const tile = ID_TO_TILE[id];
                if (tile) {
                    this.ctx.fillStyle = tile.color;
                    const tx = Math.floor(c * TILE_SIZE - this.camera.x);
                    const ty = Math.floor(r * TILE_SIZE - this.camera.y);

                    this.ctx.fillRect(tx, ty, TILE_SIZE, TILE_SIZE);
                    
                    // RENDER SHADOWS (For Base layers)
                    if (id === TILES.WALL.id || id === TILES.WOOD.id || id === TILES.BLACK.id || 
                        id === TILES.TOWER_BASE_STONE.id || id === TILES.TOWER_BASE_IRON.id || id === TILES.TOWER_BASE_GOLD.id) {
                         
                         this.ctx.fillStyle = 'rgba(0,0,0,0.5)';
                         this.ctx.fillRect(tx, ty + TILE_SIZE - 6, TILE_SIZE, 6); 
                         this.ctx.fillRect(tx + TILE_SIZE - 6, ty, 6, TILE_SIZE); 
                         this.ctx.fillStyle = 'rgba(255,255,255,0.2)';
                         this.ctx.fillRect(tx, ty, TILE_SIZE, 4); 
                         this.ctx.fillRect(tx, ty, 4, TILE_SIZE); 
                         this.ctx.fillStyle = tile.color;
                         this.ctx.fillRect(tx + 4, ty + 4, TILE_SIZE - 10, TILE_SIZE - 10);
                    }
                }
            }
        }

        // GHOST BLUEPRINT
        if (this.activeBlueprint) {
            const mx = (this.input.mouse.x / this.zoom) + this.camera.x;
            const my = (this.input.mouse.y / this.zoom) + this.camera.y;
            const gx = Math.floor(mx / TILE_SIZE);
            const gy = Math.floor(my / TILE_SIZE);
            
            this.ctx.globalAlpha = 0.5;
            this.activeBlueprint.structure.forEach(part => {
                const tile = ID_TO_TILE[part.id];
                this.ctx.fillStyle = tile.color;
                this.ctx.fillRect(
                    Math.floor((gx + part.x) * TILE_SIZE - this.camera.x),
                    Math.floor((gy + part.y) * TILE_SIZE - this.camera.y),
                    TILE_SIZE, TILE_SIZE
                );
                // Render visual parts for towers in blueprint too
                if (part.id === TILES.TOWER_BASE_STONE.id || part.id === TILES.TOWER_BASE_IRON.id || part.id === TILES.TOWER_BASE_GOLD.id) {
                    // Draw Roof and Mid for preview
                    this.ctx.fillStyle = '#555'; // Generic Barrel
                    this.ctx.fillRect(
                        Math.floor((gx + part.x) * TILE_SIZE - this.camera.x),
                        Math.floor((gy + part.y - 1) * TILE_SIZE - this.camera.y),
                        TILE_SIZE, TILE_SIZE
                    );
                    this.ctx.fillStyle = '#5C3317'; // Roof
                    this.ctx.fillRect(
                        Math.floor((gx + part.x) * TILE_SIZE - this.camera.x),
                        Math.floor((gy + part.y - 2) * TILE_SIZE - this.camera.y),
                        TILE_SIZE, TILE_SIZE
                    );
                }
            });
            this.ctx.globalAlpha = 1.0;
        }

        // PASS 2: Draw Entities
        this.lootItems.forEach(item => {
            const tile = ID_TO_TILE[item.id];
            const lx = item.x - this.camera.x;
            const bob = Math.sin((Date.now() / 200) + item.bobOffset) * 3;
            const ly = item.y - this.camera.y + bob;
            this.ctx.fillStyle = tile.color;
            this.ctx.fillRect(lx - 6, ly - 6, 12, 12);
            this.ctx.strokeStyle = '#fff';
            this.ctx.strokeRect(lx - 6, ly - 6, 12, 12);
        });

        this.ctx.fillStyle = '#ff0000'; 
        this.ctx.fillRect(
            this.player.x - this.camera.x - (TILE_SIZE/2),
            this.player.y - this.camera.y - (TILE_SIZE/2),
            TILE_SIZE, TILE_SIZE
        );
        this.drawHealthBar(this.player);

        this.npcs.forEach(npc => {
            this.ctx.fillStyle = '#000'; 
            this.ctx.fillRect(
                npc.x - this.camera.x - (TILE_SIZE/2),
                npc.y - this.camera.y - (TILE_SIZE/2),
                TILE_SIZE, TILE_SIZE
            );
            this.drawHealthBar(npc);
        });

        this.ctx.fillStyle = '#fff';
        this.projectiles.forEach(p => {
            this.ctx.beginPath();
            this.ctx.arc(p.x - this.camera.x, p.y - this.camera.y, p.size, 0, Math.PI*2);
            this.ctx.fill();
        });

        this.particles.forEach(p => {
            this.ctx.fillStyle = p.color;
            this.ctx.fillRect(p.x - this.camera.x, p.y - this.camera.y, 4, 4);
        });

        // PASS 3: Draw Overhead (Virtual) Tiles
        // We scan for Tower Bases, then draw the barrel/roof above them.
        for (let c = startCol; c <= endCol; c++) {
            for (let r = startRow; r <= endRow; r++) {
                const id = this.world.getTile(c, r);
                
                if (id === TILES.TOWER_BASE_STONE.id || id === TILES.TOWER_BASE_IRON.id || id === TILES.TOWER_BASE_GOLD.id) {
                    const tx = Math.floor(c * TILE_SIZE - this.camera.x);
                    const ty = Math.floor(r * TILE_SIZE - this.camera.y);

                    // --- RENDER MIDDLE (Barrel) ---
                    const midY = ty - TILE_SIZE;
                    const midGridY = r - 1;
                    
                    // Check transparency for Mid
                    let midAlpha = 1.0;
                    const midTile = this.world.getTile(c, midGridY);
                    // If tile is occupied by a Wall (>2) or Entity -> Transparent
                    if (midTile > 2 || this.isTileOccupiedByEntity(c, midGridY)) midAlpha = 0.5;
                    
                    this.ctx.globalAlpha = midAlpha;
                    
                    // Select Color based on base type
                    let barrelColor = TILES.STONE_BLOCK.color;
                    if (id === TILES.TOWER_BASE_IRON.id) barrelColor = TILES.IRON.color;
                    if (id === TILES.TOWER_BASE_GOLD.id) barrelColor = TILES.GOLD_2.color;

                    this.ctx.fillStyle = barrelColor;
                    this.ctx.fillRect(tx, midY, TILE_SIZE, TILE_SIZE);
                    // Shadows
                    this.ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    this.ctx.fillRect(tx, midY + TILE_SIZE - 6, TILE_SIZE, 6); 
                    this.ctx.fillRect(tx + TILE_SIZE - 6, midY, 6, TILE_SIZE); 
                    this.ctx.fillStyle = 'rgba(255,255,255,0.2)';
                    this.ctx.fillRect(tx, midY, TILE_SIZE, 4); 
                    this.ctx.fillRect(tx, midY, 4, TILE_SIZE); 
                    this.ctx.fillStyle = barrelColor;
                    this.ctx.fillRect(tx + 4, midY + 4, TILE_SIZE - 10, TILE_SIZE - 10);
                    // Muzzle
                    this.ctx.fillStyle = '#111'; 
                    this.ctx.fillRect(tx + 10, midY + 10, 12, 12);

                    // --- RENDER TOP (Roof) ---
                    const topY = ty - (TILE_SIZE * 2);
                    const topGridY = r - 2;
                    
                    let topAlpha = 1.0;
                    const topTile = this.world.getTile(c, topGridY);
                    if (topTile > 2 || this.isTileOccupiedByEntity(c, topGridY)) topAlpha = 0.5;
                    
                    this.ctx.globalAlpha = topAlpha;

                    this.ctx.fillStyle = '#4A2E19'; 
                    this.ctx.fillRect(tx, topY, TILE_SIZE, TILE_SIZE);
                    this.ctx.fillStyle = TILES.ROOF.color; 
                    this.ctx.beginPath();
                    this.ctx.moveTo(tx, topY + TILE_SIZE);
                    this.ctx.lineTo(tx + TILE_SIZE, topY + TILE_SIZE);
                    this.ctx.lineTo(tx + TILE_SIZE/2, topY);
                    this.ctx.fill();

                    this.ctx.globalAlpha = 1.0;
                }
            }
        }
        
        this.ctx.font = "bold 14px 'Courier New'";
        this.damageTexts.forEach(d => {
            this.ctx.fillStyle = d.color;
            if (typeof d.amount === 'string') {
                this.ctx.fillText(d.amount, d.x - this.camera.x, d.y - this.camera.y);
            } else {
                this.ctx.fillText(Math.floor(d.amount), d.x - this.camera.x, d.y - this.camera.y);
            }
        });
        
        this.ctx.font = "10px monospace";
        this.cannons.forEach(c => {
            const cx = c.x - this.camera.x;
            const cy = c.y - this.camera.y;
            this.ctx.fillStyle = c.ammo > 0 ? '#00ffff' : '#ff0000';
            this.ctx.fillText(`A:${c.ammo}`, cx - 10, cy - 25);
        });
        
        if (this.input.mouse.left || this.activeBlueprint) {
             this.ctx.strokeStyle = 'rgba(255,255,255,0.1)';
             this.ctx.beginPath();
             this.ctx.arc(this.player.x - this.camera.x, this.player.y - this.camera.y, BUILD_RANGE, 0, Math.PI*2);
             this.ctx.stroke();
        }
        
        this.ctx.restore();
    }

    loop(timestamp) {
        const dt = timestamp - this.lastTime;
        this.lastTime = timestamp;
        this.update(dt);
        this.draw();
        requestAnimationFrame(t => this.loop(t));
    }
}

window.onload = () => {
    const msg = document.getElementById('messages');
    msg.innerHTML = "SURVIVE.<br><small>Click 'Open Blueprints' to build structures.</small>";
    setTimeout(() => msg.style.opacity = 0, 5000);
    new Game();
};

</script>
</body>
</html>