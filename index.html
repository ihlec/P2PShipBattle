<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Warfare Engine v2.21 (Optimized Math)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: 'Courier New', Courier, monospace; color: #eee; user-select: none; }
        canvas { display: block; image-rendering: pixelated; }
        #ui-layer { position: absolute; top: 10px; left: 10px; pointer-events: none; }
        .stat-box { background: rgba(0, 0, 0, 0.7); padding: 10px; border: 2px solid #555; margin-bottom: 5px; pointer-events: auto; }
        #inventory-bar { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 5px; background: rgba(0,0,0,0.8); padding: 10px; border-radius: 8px; pointer-events: auto; }
        .slot { width: 50px; height: 50px; border: 2px solid #444; cursor: pointer; display: flex; justify-content: center; align-items: center; font-size: 10px; position: relative; flex-direction: column; transition: border-color 0.2s; }
        .slot.active { border-color: #ffd700; box-shadow: 0 0 10px #ffd700; }
        .slot-color { width: 20px; height: 20px; border: 1px solid #000; margin-bottom: 2px; }
        .qty { position: absolute; bottom: 2px; right: 2px; font-weight: bold; font-size: 9px;}
        .short-name { font-size: 10px; color: #aaa; text-transform: uppercase; }
        #messages { position: absolute; top: 10%; width: 100%; text-align: center; font-size: 24px; text-shadow: 2px 2px 0 #000; pointer-events: none; transition: opacity 1s; }
        #blueprint-menu { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.95); border: 2px solid #777; padding: 20px; grid-template-columns: repeat(3, 1fr); gap: 10px; pointer-events: auto; z-index: 100; box-shadow: 0 0 20px #000; }
        .bp-item { border: 1px solid #444; padding: 10px; text-align: center; cursor: pointer; transition: background 0.2s; }
        .bp-item:hover { background: #333; border-color: #fff; }
        
        .bp-item.disabled { opacity: 0.4; cursor: not-allowed; border-color: #444; }
        .bp-item.disabled:hover { background: transparent; border-color: #444; }

        .bp-name { font-weight: bold; margin-bottom: 5px; color: #ffd700; }
        .bp-req { font-size: 10px; color: #ccc; }
        #hammer-btn { position: absolute; bottom: 30px; left: 20px; width: 50px; height: 50px; background: rgba(0,0,0,0.8); border: 2px solid #444; border-radius: 8px; font-size: 24px; color: #eee; cursor: pointer; pointer-events: auto; z-index: 100; display: flex; justify-content: center; align-items: center; transition: all 0.2s; }
        #hammer-btn:hover { border-color: #fff; background: #333; transform: scale(1.1); }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="stat-box">
            <div>Health: <span id="hp">100</span></div>
            <div>Pos: <span id="coords">0, 0</span></div>
            <div>Biome: <span id="biome-disp"></span></div>
            <div>Elev: <span id="elev-disp"></span> | Seed: <span id="seed-disp"></span></div>
        </div>
        <div class="stat-box">
            <small>WASD: Move | Click: Build | R-Click: Break/Harvest</small>
            <div id="active-bp-display" style="color: #ffd700; font-size: 12px; display:none; margin-top:5px;">
                Active: <span id="current-bp-name"></span>
            </div>
        </div>
    </div>

    <div id="messages"></div>
    <button id="hammer-btn" onclick="toggleBlueprints()" title="Open Blueprints">ðŸ”¨</button>

    <div id="blueprint-menu"></div>
    <div id="inventory-bar"></div>
    <canvas id="gameCanvas"></canvas>

<script>
// --- CONSTANTS & CONFIG ---
const CONFIG = {
    TILE_SIZE: 32,
    PLAYER_SPEED_BASE: 4,
    PLAYER_SPEED_ROAD: 8,
    NPC_SPAWN_RATE: 0.002, 
    BUILD_RANGE: 400,
    MAX_NPCS: 30
};

const TILES = {
    WATER: { id: 0, color: '#2b2b96', solid: true, name: 'Ocean', short: 'H2O' },
    DEEP_WATER: { id: 18, color: '#1a1a6e', solid: true, name: 'Deep Ocean', short: 'D.H2O' },
    GRASS: { id: 1, color: '#2d6e32', solid: false, name: 'Grass', short: 'Grs' },
    SAND:  { id: 2, color: '#c2b280', solid: false, name: 'Sand', short: 'Snd' },
    GREY:  { id: 3, color: '#777777', solid: false, name: 'Stone/Road', short: 'Stn' },
    BLACK: { id: 4, color: '#111111', solid: false, name: 'Obsidian', short: 'Obs' }, 
    IRON:  { id: 5, color: '#444444', solid: false, name: 'Iron', short: 'Irn' }, 
    GOLD:  { id: 7, color: '#ffd700', solid: false, name: 'Gold', short: 'Gld' },
    WALL:  { id: 9, color: '#555555', solid: true, name: 'Wall', short: 'Wal' },
    WOOD:  { id: 10, color: '#8B4513', solid: false, name: 'Wood', short: 'Wod' },
    STONE_BLOCK: { id: 11, color: '#777777', solid: true, name: 'Boulder', short: 'Bld' }, 
    TOWER_BASE_STONE: { id: 12, color: '#555555', solid: true, name: 'Stone Tower', short: 'T.St' },
    TOWER_BASE_IRON:  { id: 14, color: '#333333', solid: true, name: 'Iron Tower', short: 'T.Ir' },
    TOWER_BASE_GOLD:  { id: 15, color: '#886600', solid: true, name: 'Gold Tower', short: 'T.Gd' },
    ROOF: { id: 13, color: '#5C3317', solid: false, name: 'Roof', short: 'Rof' },
    WOOD_WALL: { id: 16, color: '#6F4E37', solid: true, name: 'Wood Wall', short: 'W.Wal' },
    WOOD_RAIL: { id: 17, color: '#A0522D', solid: true, name: 'Wood Rail', short: 'W.Ral' },
    TREE: { id: 19, color: '#2d6e32', solid: true, name: 'Tree', short: 'Tre' },
    MOUNTAIN: { id: 20, color: '#999', solid: true, name: 'Mountain', short: 'Mnt' },
    GREENS: { id: 21, color: '#32CD32', solid: false, name: 'Greens', short: 'Grn' }
};

const ID_TO_TILE = Object.values(TILES).reduce((acc, t) => { acc[t.id] = t; return acc; }, {});

const BLUEPRINTS = [
    { name: "Stone Tower", structure: [{x:0, y:0, id: TILES.TOWER_BASE_STONE.id}], cost: { [TILES.GREY.id]: 4, [TILES.WOOD.id]: 1 } },
    { name: "Iron Tower", structure: [{x:0, y:0, id: TILES.TOWER_BASE_IRON.id}], cost: { [TILES.GREY.id]: 1, [TILES.IRON.id]: 3, [TILES.WOOD.id]: 1 } },
    { name: "Gold Tower", structure: [{x:0, y:0, id: TILES.TOWER_BASE_GOLD.id}], cost: { [TILES.GREY.id]: 1, [TILES.GOLD.id]: 3, [TILES.WOOD.id]: 1 } },
    { name: "Stone Wall", structure: [{x:0, y:0, id: TILES.WALL.id}], cost: { [TILES.GREY.id]: 2 } },
    { name: "Wood Wall", structure: [{x:0, y:0, id: TILES.WOOD_WALL.id}], cost: { [TILES.WOOD.id]: 2 } },
    { name: "Bridge Block", structure: [{x:0, y:0, id: TILES.GREY.id}], cost: { [TILES.GREY.id]: 1, [TILES.WOOD.id]: 1 }, special: 'bridge' },
    { name: "Road Segment", structure: [{x:0, y:0, id: TILES.GREY.id}], cost: { [TILES.GREY.id]: 1 } }
];

// --- UTILS ---
function toggleBlueprints() {
    const menu = document.getElementById('blueprint-menu');
    menu.style.display = menu.style.display === 'grid' ? 'none' : 'grid';
}

class Utils {
    // OPTIMIZED HASH: Uses 32-bit integer multiplication for robust, uniform distribution
    static hash(x, y, seed) {
        let h = seed ^ Math.imul(x, 374761393) ^ Math.imul(y, 668265263);
        h = Math.imul(h ^ (h >>> 13), 1274126177);
        return h ^ (h >>> 16);
    }
    
    static noise(x, y, seed) {
        const s = Utils.hash(Math.floor(x), Math.floor(y), seed);
        // Unsigned shift (>>> 0) ensures positive integer range [0, 4294967295]
        // Dividing by max uint32 gives strict [0.0, 1.0] range
        return (s >>> 0) / 4294967296; 
    }
    
    static hsl(h, s, l, x, y, seed, hVar, lVar) {
        const r1 = Utils.noise(x, y, seed); 
        const r2 = Utils.noise(x, y, seed + 100); 
        const newH = h + (r1 * hVar * 2) - hVar;
        const newL = l + (r2 * lVar * 2) - lVar;
        return `hsl(${newH}, ${s}%, ${newL}%)`;
    }

    static lerp(a, b, t) { return a + t * (b - a); }
    static smoothstep(t) { return t * t * (3 - 2 * t); }

    static valueNoise2D(x, y, seed) {
        const iX = Math.floor(x);
        const iY = Math.floor(y);
        const fX = x - iX;
        const fY = y - iY;
        
        const sX = Utils.smoothstep(fX);
        const sY = Utils.smoothstep(fY);
        
        const n00 = Utils.noise(iX, iY, seed);
        const n10 = Utils.noise(iX + 1, iY, seed);
        const n01 = Utils.noise(iX, iY + 1, seed);
        const n11 = Utils.noise(iX + 1, iY + 1, seed);
        
        const ix0 = Utils.lerp(n00, n10, sX);
        const ix1 = Utils.lerp(n01, n11, sX);
        
        return Utils.lerp(ix0, ix1, sY);
    }
    
    static getElevation(x, y, seed) {
        let amp = 1;
        let freq = 0.01; 
        let total = 0;
        let maxAmp = 0;
        
        for(let i = 0; i < 4; i++) {
            total += Utils.valueNoise2D(x * freq, y * freq, seed) * amp;
            maxAmp += amp;
            amp *= 0.5;
            freq *= 2;
        }
        
        // Normalized [0.0, 1.0]
        const normalized = total / maxAmp;
        
        // Strict Mapping [-1.0, 1.0]. No biases.
        return normalized * 2 - 1; 
    }

    static getBiome(x, y, seed) {
        const n = Utils.getElevation(x, y, seed);

        // --- CLEAN THRESHOLDS (Centered at 0.0) ---
        
        // Water < -0.25 means roughly 38% of map is water
        if (n < -0.2) return TILES.DEEP_WATER.id;
        if (n < 0.25) return TILES.WATER.id; 
        if (n < 0.3) return TILES.SAND.id; // Thin beach (-0.25 to -0.15)
        
        // Land >= -0.15
        
        if (n > 0.6) return TILES.MOUNTAIN.id; // Peaks
        
        // Forest (0.15 to 0.6)
        if (n > 0.45) {
            const tNoise = Utils.noise(x, y, seed + 999);
            // 60% Density
            if (tNoise < 0.6) {
                const rockChance = Utils.noise(x, y, seed + 444);
                if (rockChance < 0.02) return TILES.STONE_BLOCK.id;
                return TILES.TREE.id;
            }
            return TILES.GRASS.id; 
        }
        
        // Plains (-0.15 to 0.15)
        const scattered = Utils.noise(x, y, seed + 888);
        if (scattered < 0.05) {
             const rockChance = Utils.noise(x, y, seed + 555);
             if (rockChance < 0.1) return TILES.STONE_BLOCK.id;
             return TILES.TREE.id;
        }

        const rockNoise = Utils.noise(x, y, seed + 333);
        if (rockNoise < 0.005) return TILES.STONE_BLOCK.id;

        return TILES.GRASS.id;
    }
    
    static distance(e1, e2) { return Math.sqrt((e1.x - e2.x)**2 + (e1.y - e2.y)**2); }
}

// --- ENGINE CORE ---

class InputHandler {
    constructor() {
        this.keys = {};
        this.mouse = { x: 0, y: 0, left: false, right: false, clickedLeft: false, clickedRight: false };
        this.wheel = 0;

        window.addEventListener('keydown', e => {
            this.keys[e.key.toLowerCase()] = true;
            if(e.key.toLowerCase() === 'escape') document.getElementById('blueprint-menu').style.display = 'none';
            if(e.key.toLowerCase() === 'b') toggleBlueprints();
        });
        window.addEventListener('keyup', e => this.keys[e.key.toLowerCase()] = false);
        window.addEventListener('mousemove', e => { this.mouse.x = e.clientX; this.mouse.y = e.clientY; });
        window.addEventListener('mousedown', e => {
            if(e.target.tagName !== 'CANVAS') return;
            if(e.button === 0) { this.mouse.left = true; this.mouse.clickedLeft = true; }
            if(e.button === 2) { this.mouse.right = true; this.mouse.clickedRight = true; }
        });
        window.addEventListener('mouseup', e => { this.mouse.left = false; this.mouse.right = false; });
        window.addEventListener('contextmenu', e => e.preventDefault());
        window.addEventListener('wheel', e => { this.wheel += e.deltaY; e.preventDefault(); }, { passive: false });
    }

    flush() {
        this.mouse.clickedLeft = false;
        this.mouse.clickedRight = false;
        this.wheel = 0;
    }
}

class Particle {
    constructor(x, y, color, dx, dy, life) {
        this.x = x; this.y = y; this.color = color;
        this.dx = dx; this.dy = dy; 
        this.life = life; this.maxLife = life;
    }
    update() { this.x += this.dx; this.y += this.dy; this.life--; }
    draw(ctx, camX, camY) {
        ctx.globalAlpha = Math.max(0, this.life / this.maxLife);
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x - camX, this.y - camY, 4, 4);
        ctx.globalAlpha = 1.0;
    }
}

class World {
    constructor(seed) {
        this.seed = seed || Math.floor(Math.random() * 10000);
        this.modifiedTiles = {}; 
        this.tileData = {}; 
    }
    getKey(x, y) { return `${x},${y}`; }
    getTile(x, y) { return this.modifiedTiles[this.getKey(x, y)] !== undefined ? this.modifiedTiles[this.getKey(x, y)] : Utils.getBiome(x, y, this.seed); }
    setTile(x, y, id) { 
        const key = this.getKey(x, y);
        this.modifiedTiles[key] = id;
        if (this.tileData[key]) delete this.tileData[key]; 
    }
    isSolid(x, y) { return ID_TO_TILE[this.getTile(x, y)].solid; }

    hitTile(x, y, dmg) {
        const key = this.getKey(x, y);
        if (!this.tileData[key]) this.tileData[key] = { dmg: 0 };
        this.tileData[key].dmg += dmg;
        return this.tileData[key].dmg;
    }
    getTileDamage(x, y) {
        const key = this.getKey(x, y);
        return this.tileData[key] ? this.tileData[key].dmg : 0;
    }
}

class Entity {
    constructor(x, y, type) {
        this.x = x; this.y = y; this.type = type;
        this.speed = CONFIG.PLAYER_SPEED_BASE;
        this.hp = 100;
        this.damageBuffer = 0;
        this.inventory = { [TILES.GREY.id]: 50, [TILES.BLACK.id]: 20, [TILES.GOLD.id]: 20, [TILES.IRON.id]: 50, [TILES.WOOD.id]: 20, [TILES.GREENS.id]: 0 };
        this.selectedTile = TILES.GREY.id;
    }
    
    move(dx, dy, world) {
        const half = (CONFIG.TILE_SIZE / 2) - 4; 
        const check = (tx, ty) => {
            if (world.isSolid(Math.floor((tx - half)/CONFIG.TILE_SIZE), Math.floor((ty - half)/CONFIG.TILE_SIZE))) return false;
            if (world.isSolid(Math.floor((tx + half)/CONFIG.TILE_SIZE), Math.floor((ty - half)/CONFIG.TILE_SIZE))) return false;
            if (world.isSolid(Math.floor((tx - half)/CONFIG.TILE_SIZE), Math.floor((ty + half)/CONFIG.TILE_SIZE))) return false;
            if (world.isSolid(Math.floor((tx + half)/CONFIG.TILE_SIZE), Math.floor((ty + half)/CONFIG.TILE_SIZE))) return false;
            return true;
        };
        
        if (check(this.x + dx, this.y)) this.x += dx;
        if (check(this.x, this.y + dy)) this.y += dy;

        const gx = Math.floor(this.x / CONFIG.TILE_SIZE);
        const gy = Math.floor(this.y / CONFIG.TILE_SIZE);
        this.speed = (world.getTile(gx, gy) === TILES.GREY.id) ? CONFIG.PLAYER_SPEED_ROAD : CONFIG.PLAYER_SPEED_BASE;
    }
}

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        window.addEventListener('resize', () => this.resize());

        this.input = new InputHandler();
        this.world = new World();
        this.player = new Entity(0, 0, 'player');
        const spawn = this.findSafeSpawn();
        this.player.x = spawn.x; this.player.y = spawn.y;

        this.npcs = [];
        this.loot = [];
        this.projectiles = [];
        this.particles = [];
        this.texts = [];
        this.cannons = []; 
        
        this.camera = { x: 0, y: 0 };
        this.zoom = 1;
        this.lastTime = 0;
        this.regenTimer = 0;
        this.godMode = false;
        this.activeBlueprint = null;
        
        this.dom = {
            hp: document.getElementById('hp'),
            coords: document.getElementById('coords'),
            seed: document.getElementById('seed-disp'),
            invBar: document.getElementById('inventory-bar'),
            bpMenu: document.getElementById('blueprint-menu'),
            activeBp: document.getElementById('active-bp-display'),
            bpName: document.getElementById('current-bp-name'),
            elev: document.getElementById('elev-disp'),
            biome: document.getElementById('biome-disp') 
        };
        
        this.dom.seed.innerText = this.world.seed;
        this.initUI();
        
        window.addEventListener('keyup', (e) => {
            if (e.key.toLowerCase() === 'g') {
                this.godMode = !this.godMode;
                this.showMessage(this.godMode ? "GOD MODE ON" : "GOD MODE OFF");
                this.updateUI(); 
            }
        });

        requestAnimationFrame(t => this.loop(t));
    }

    resize() { this.canvas.width = window.innerWidth; this.canvas.height = window.innerHeight; }

    showMessage(text) {
        const msg = document.getElementById('messages');
        msg.innerHTML = text;
        msg.style.opacity = 1;
        setTimeout(() => msg.style.opacity = 0, 2000);
    }

    initUI() {
        this.dom.invBar.innerHTML = ''; 
        const usable = [TILES.GREY, TILES.BLACK, TILES.IRON, TILES.GOLD, TILES.WOOD, TILES.GREENS];
        usable.forEach((t) => {
            const slot = document.createElement('div');
            slot.className = 'slot';
            slot.innerHTML = `<div class="slot-color" style="background:${t.color}"></div><div class="short-name">${t.short}</div><div class="qty" id="qty-${t.id}">0</div>`;
            slot.onclick = () => {
                this.player.selectedTile = t.id;
                this.activeBlueprint = null;
                this.updateUI();
            };
            this.dom.invBar.appendChild(slot);
        });
        
        this.dom.bpMenu.innerHTML = '';
        BLUEPRINTS.forEach((bp, index) => {
            const div = document.createElement('div');
            div.className = 'bp-item';
            let costStr = "Free";
            if (bp.cost) {
                costStr = Object.entries(bp.cost)
                    .map(([id, qty]) => `${qty} ${ID_TO_TILE[id].short}`)
                    .join(', ');
            }
            div.innerHTML = `<div class="bp-name">${bp.name}</div><div class="bp-req">${costStr}</div>`;
            div.onclick = () => { 
                if (div.classList.contains('disabled')) return;
                this.activeBlueprint = bp; 
                toggleBlueprints(); 
                this.updateUI(); 
            };
            this.dom.bpMenu.appendChild(div);
        });
        this.updateUI();
    }

    updateUI() {
        const slots = document.querySelectorAll('.slot');
        const usable = [TILES.GREY, TILES.BLACK, TILES.IRON, TILES.GOLD, TILES.WOOD, TILES.GREENS];
        slots.forEach((s, i) => {
            const id = usable[i].id;
            s.classList.toggle('active', !this.activeBlueprint && id === this.player.selectedTile);
            const qtyEl = document.getElementById(`qty-${id}`);
            if(qtyEl) qtyEl.innerText = this.player.inventory[id] || 0;
        });

        const bpItems = this.dom.bpMenu.children;
        BLUEPRINTS.forEach((bp, i) => {
            const div = bpItems[i];
            let canAfford = true;
            if (bp.cost && !this.godMode) {
                for (const [id, qty] of Object.entries(bp.cost)) {
                    if ((this.player.inventory[id] || 0) < qty) {
                        canAfford = false;
                        break;
                    }
                }
            }
            if (canAfford) div.classList.remove('disabled');
            else div.classList.add('disabled');
        });

        if(this.activeBlueprint) {
            this.dom.activeBp.style.display = 'block';
            this.dom.bpName.innerText = this.activeBlueprint.name;
        } else {
            this.dom.activeBp.style.display = 'none';
        }
    }

    findSafeSpawn() {
        for (let r = 0; r < 500; r++) {
            const x = (Math.random() - 0.5) * 2000;
            const y = (Math.random() - 0.5) * 2000;
            const gx = Math.floor(x/CONFIG.TILE_SIZE);
            const gy = Math.floor(y/CONFIG.TILE_SIZE);
            const t = this.world.getTile(gx, gy);
            if (!ID_TO_TILE[t].solid && t !== TILES.WATER.id && t !== TILES.DEEP_WATER.id) return {x, y};
        }
        let r = 0;
        while (r < 100) {
            for (let x = -r; x <= r; x++) {
                for (let y = -r; y <= r; y++) {
                    const t = this.world.getTile(x, y);
                    if (!ID_TO_TILE[t].solid && t !== TILES.WATER.id && t !== TILES.DEEP_WATER.id) {
                        return {x: x*CONFIG.TILE_SIZE, y: y*CONFIG.TILE_SIZE};
                    }
                }
            }
            r++;
        }
        return {x: 0, y: 0};
    }

    // --- LOGIC ---
    
    handleInteraction() {
        if (!this.input.mouse.clickedLeft && !this.input.mouse.clickedRight) return;

        const mx = (this.input.mouse.x / this.zoom) + this.camera.x;
        const my = (this.input.mouse.y / this.zoom) + this.camera.y;
        const gx = Math.floor(mx / CONFIG.TILE_SIZE);
        const gy = Math.floor(my / CONFIG.TILE_SIZE);

        if (Utils.distance(this.player, {x: mx, y: my}) > CONFIG.BUILD_RANGE) return;

        if (this.input.mouse.clickedLeft) {
            if (this.player.selectedTile === TILES.TREE.id || this.player.selectedTile === TILES.MOUNTAIN.id) return;

            const cannon = this.cannons.find(c => {
                const [cx, cy] = c.key.split(',').map(Number);
                return gx === cx && gy === cy;
            });
            if (cannon && this.player.selectedTile === TILES.IRON.id) {
                if (this.player.inventory[TILES.IRON.id] > 0 || this.godMode) {
                    if (!this.godMode) this.player.inventory[TILES.IRON.id]--;
                    cannon.ammo += 5;
                    this.spawnText(cannon.x, cannon.y, "+5 AMMO", "#00ffff");
                    this.updateUI();
                    return;
                }
            }

            const canAfford = (id, cost) => this.godMode || (this.player.inventory[id] || 0) >= cost;
            const consume = (id, cost) => { if(!this.godMode) this.player.inventory[id] -= cost; };

            if (this.activeBlueprint) {
                const costMap = this.activeBlueprint.cost || {};
                
                if (this.activeBlueprint.special === 'bridge') {
                    const targetId = this.world.getTile(gx, gy);
                    if (targetId !== TILES.WATER.id && targetId !== TILES.DEEP_WATER.id && targetId !== TILES.WOOD_RAIL.id) {
                         this.spawnText(mx * this.zoom, my * this.zoom, "MUST BUILD ON WATER/RAIL", "#f00");
                         return;
                    }
                } else if (this.activeBlueprint.requiresWater) {
                    const targetId = this.world.getTile(gx, gy);
                    if (targetId !== TILES.WATER.id && targetId !== TILES.DEEP_WATER.id) {
                         this.spawnText(mx * this.zoom, my * this.zoom, "MUST BUILD ON WATER", "#f00");
                         return;
                    }
                }

                let affordable = true;
                for (let [id, qty] of Object.entries(costMap)) {
                    if (!canAfford(id, qty)) affordable = false;
                }

                if (affordable) {
                    let built = false;
                    const isBridgeBp = this.activeBlueprint.special === 'bridge' || this.activeBlueprint.requiresWater;

                    this.activeBlueprint.structure.forEach(part => {
                        const overwriteRail = this.activeBlueprint.special === 'bridge';
                        if (this.tryBuild(gx + part.x, gy + part.y, part.id, overwriteRail, isBridgeBp)) built = true;
                    });
                    
                    if (built) {
                        for (let [id, qty] of Object.entries(costMap)) consume(id, qty);
                        
                        if (this.activeBlueprint.special === 'bridge') {
                            const neighbors = [
                                {x:gx+1, y:gy}, {x:gx-1, y:gy},
                                {x:gx, y:gy+1}, {x:gx, y:gy-1}
                            ];
                            neighbors.forEach(n => {
                                const nid = this.world.getTile(n.x, n.y);
                                if (nid === TILES.WATER.id || nid === TILES.DEEP_WATER.id) {
                                    this.world.setTile(n.x, n.y, TILES.WOOD_RAIL.id);
                                    this.spawnParticles(n.x * CONFIG.TILE_SIZE + 16, n.y * CONFIG.TILE_SIZE + 16, TILES.WOOD.color, 4);
                                }
                            });
                        }
                        this.updateUI();
                        this.recalcCannons();
                    }
                }
            } else {
                const id = this.player.selectedTile;
                if (canAfford(id, 1)) {
                    if (this.tryBuild(gx, gy, id, false, false)) {
                        consume(id, 1);
                        this.updateUI();
                        this.recalcCannons();
                    }
                }
            }
        } else if (this.input.mouse.clickedRight) {
            if (this.activeBlueprint) {
                this.activeBlueprint = null;
                this.updateUI();
            } else {
                let tx = gx, ty = gy;
                let tileId = this.world.getTile(gx, gy);
                
                if (tileId === TILES.WOOD_RAIL.id) {
                     this.spawnText(mx * this.zoom, my * this.zoom, "BREAK ROAD TO DEMOLISH", "#f00");
                     return;
                }
                
                if (!ID_TO_TILE[tileId].solid && tileId !== TILES.TREE.id) {
                    let below = this.world.getTile(gx, gy + 1);
                    if ([12,14,15].includes(below)) { ty = gy + 1; tileId = below; }
                    else {
                        let below2 = this.world.getTile(gx, gy + 2);
                        if ([12,14,15].includes(below2)) { ty = gy + 2; tileId = below2; }
                    }
                }

                if (tileId !== TILES.GRASS.id && tileId !== TILES.WATER.id && tileId !== TILES.DEEP_WATER.id && tileId !== TILES.SAND.id) {
                    if (tileId === TILES.TREE.id) {
                        this.world.setTile(tx, ty, TILES.GRASS.id);
                        this.spawnParticles(tx * CONFIG.TILE_SIZE + 16, ty * CONFIG.TILE_SIZE + 16, TILES.WOOD.color, 8);
                        this.loot.push({x: tx*CONFIG.TILE_SIZE + 16, y: ty*CONFIG.TILE_SIZE + 16, id: TILES.WOOD.id, qty: 3, bob: Math.random()*100});
                        
                        if (Math.random() < 0.1) {
                            this.loot.push({x: tx*CONFIG.TILE_SIZE + 16, y: ty*CONFIG.TILE_SIZE + 16, id: TILES.GREENS.id, qty: 1, bob: Math.random()*100});
                        }
                        this.updateUI();
                        return;
                    }

                    if (tileId === TILES.MOUNTAIN.id || tileId === TILES.STONE_BLOCK.id) {
                        const dmg = 20; 
                        const totalDmg = this.world.hitTile(tx, ty, dmg);
                        const maxHp = 100;
                        
                        this.spawnParticles(tx * CONFIG.TILE_SIZE + 16, ty * CONFIG.TILE_SIZE + 16, '#777', 3);
                        this.spawnText(tx * CONFIG.TILE_SIZE + 16, ty * CONFIG.TILE_SIZE, `-${dmg}`, '#fff');

                        if (totalDmg >= maxHp) {
                            const biome = Utils.getBiome(tx, ty, this.world.seed);
                            this.world.setTile(tx, ty, TILES.GRASS.id); 
                            this.spawnParticles(tx * CONFIG.TILE_SIZE + 16, ty * CONFIG.TILE_SIZE + 16, '#555', 10);
                            
                            let stoneQty = 3;
                            if (Math.random() < 0.1) {
                                this.loot.push({x: tx*CONFIG.TILE_SIZE + 16, y: ty*CONFIG.TILE_SIZE + 16, id: TILES.IRON.id, qty: 2, bob: Math.random()*100});
                            }
                            if (Math.random() < 0.01) {
                                this.loot.push({x: tx*CONFIG.TILE_SIZE + 16, y: ty*CONFIG.TILE_SIZE + 16, id: TILES.GOLD.id, qty: 1, bob: Math.random()*100});
                            }
                            this.loot.push({x: tx*CONFIG.TILE_SIZE + 16, y: ty*CONFIG.TILE_SIZE + 16, id: TILES.GREY.id, qty: stoneQty, bob: Math.random()*100});
                        }
                        return; 
                    }

                    const tilesToRemove = [{x: tx, y: ty}];
                    if (tileId === TILES.GREY.id) {
                        const neighbors = [
                            {x:tx+1, y:ty}, {x:tx-1, y:ty},
                            {x:tx, y:ty+1}, {x:tx, y:ty-1}
                        ];
                        neighbors.forEach(n => {
                            if (this.world.getTile(n.x, n.y) === TILES.WOOD_RAIL.id) {
                                const railNeighbors = [
                                    {x:n.x+1, y:n.y}, {x:n.x-1, y:n.y},
                                    {x:n.x, y:n.y+1}, {x:n.x, y:n.y-1}
                                ];
                                const support = railNeighbors.some(rn => 
                                    (rn.x !== tx || rn.y !== ty) && this.world.getTile(rn.x, rn.y) === TILES.GREY.id
                                );
                                if (!support) tilesToRemove.push({x: n.x, y: n.y});
                            }
                        });
                    }

                    const allEntities = [this.player, ...this.npcs];
                    const isOccupied = tilesToRemove.some(t => {
                        const tileCenter = { x: t.x * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE/2, y: t.y * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE/2 };
                        return allEntities.some(e => Utils.distance(e, tileCenter) < CONFIG.TILE_SIZE/1.5);
                    });

                    if (isOccupied) {
                        this.spawnText(mx * this.zoom, my * this.zoom, "CANNOT BREAK: OCCUPIED", "#f00");
                        return;
                    }

                    const biome = Utils.getBiome(tx, ty, this.world.seed);
                    let restoreId = TILES.GRASS.id;
                    if (biome === TILES.WATER.id) restoreId = TILES.WATER.id;
                    if (biome === TILES.DEEP_WATER.id) restoreId = TILES.DEEP_WATER.id;
                    if (biome === TILES.SAND.id) restoreId = TILES.SAND.id;

                    this.world.setTile(tx, ty, restoreId);
                    
                    if (!this.godMode) {
                        if ([12,14,15].includes(tileId)) {
                             this.player.inventory[TILES.GREY.id] += 4;
                             this.player.inventory[TILES.WOOD.id] += 1;
                        } else {
                             this.player.inventory[tileId]++;
                        }
                    }
                    this.spawnParticles(tx * CONFIG.TILE_SIZE + 16, ty * CONFIG.TILE_SIZE + 16, '#777', 5);
                    
                    tilesToRemove.forEach(t => {
                        if (t.x === tx && t.y === ty) return;
                        const rBiome = Utils.getBiome(t.x, t.y, this.world.seed);
                        const rRestore = (rBiome === TILES.WATER.id || rBiome === TILES.DEEP_WATER.id) ? rBiome : TILES.GRASS.id;
                        this.world.setTile(t.x, t.y, rRestore);
                        this.spawnParticles(t.x * CONFIG.TILE_SIZE + 16, t.y * CONFIG.TILE_SIZE + 16, TILES.WOOD.color, 4);
                        if (!this.godMode) this.player.inventory[TILES.WOOD.id] += 1;
                    });
                    this.recalcCannons();
                    this.updateUI();
                }
            }
        }
    }

    tryBuild(gx, gy, id, allowRailOverwrite = false, isBridge = false) {
        const tx = gx * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE/2;
        const ty = gy * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE/2;
        
        const allEntities = [...this.npcs, this.player];
        for (let e of allEntities) {
            if (Utils.distance({x:tx, y:ty}, e) < CONFIG.TILE_SIZE/1.5) return false;
        }
        
        const current = this.world.getTile(gx, gy);
        if (current === id) return false;
        
        if ((current === TILES.WATER.id || current === TILES.DEEP_WATER.id) && !isBridge) return false;
        
        if (allowRailOverwrite && current === TILES.WOOD_RAIL.id) {
            this.world.setTile(gx, gy, id);
            return true;
        }

        if (ID_TO_TILE[current].solid && current !== TILES.WATER.id && current !== TILES.DEEP_WATER.id) return false;
        
        this.world.setTile(gx, gy, id);
        return true;
    }

    recalcCannons() {
        const range = 30;
        const px = Math.floor(this.player.x / CONFIG.TILE_SIZE);
        const py = Math.floor(this.player.y / CONFIG.TILE_SIZE);
        const newCannons = [];
        for (let y = py - range; y < py + range; y++) {
            for (let x = px - range; x < px + range; x++) {
                const id = this.world.getTile(x, y);
                if ([12, 14, 15].includes(id)) {
                    const key = `${x},${y}`;
                    let damage = (id===12)?20 : (id===14)?40 : 80;
                    const existing = this.cannons.find(c => c.key === key);
                    newCannons.push({
                        key, x: x*CONFIG.TILE_SIZE + CONFIG.TILE_SIZE/2, y: y*CONFIG.TILE_SIZE + CONFIG.TILE_SIZE/2,
                        damage, cooldown: existing ? existing.cooldown : 0, ammo: existing ? existing.ammo : 10, range: 300
                    });
                }
            }
        }
        this.cannons = newCannons;
    }

    spawnText(x, y, txt, col) { 
        this.texts.push({x, y, txt, col, life: 60, dy: -1}); 
    }
    
    spawnParticles(x, y, color, count) {
        for(let i=0; i<count; i++) {
            this.particles.push(new Particle(x, y, color, (Math.random()-0.5)*5, (Math.random()-0.5)*5, 30 + Math.random()*20));
        }
    }

    update(dt) {
        if (this.input.wheel !== 0) {
            // FIX: Allow zoom out to 0.05 to find land
            this.zoom = Math.max(0.05, Math.min(this.zoom - this.input.wheel * 0.001, 3));
        }

        this.regenTimer += dt;
        if (this.regenTimer > 2000 && this.player.hp < 100) {
            this.player.hp = Math.min(100, this.player.hp + 5);
            this.spawnText(this.player.x, this.player.y - 20, "+5 HP", "#0f0");
            this.regenTimer = 0;
        }

        let dx = 0, dy = 0;
        if(this.input.keys['w'] || this.input.keys['arrowup']) dy = -1;
        if(this.input.keys['s'] || this.input.keys['arrowdown']) dy = 1;
        if(this.input.keys['a'] || this.input.keys['arrowleft']) dx = -1;
        if(this.input.keys['d'] || this.input.keys['arrowright']) dx = 1;
        
        if (dx || dy) {
            const len = Math.sqrt(dx*dx + dy*dy);
            this.player.move((dx/len)*this.player.speed, (dy/len)*this.player.speed, this.world);
        }

        const viewW = this.canvas.width / this.zoom;
        const viewH = this.canvas.height / this.zoom;
        this.camera.x = this.player.x - viewW/2;
        this.camera.y = this.player.y - viewH/2;

        this.handleInteraction();

        if (this.npcs.length < CONFIG.MAX_NPCS && Math.random() < CONFIG.NPC_SPAWN_RATE) {
            const ang = Math.random() * 6.28;
            const dist = 600;
            const nx = this.player.x + Math.cos(ang)*dist;
            const ny = this.player.y + Math.sin(ang)*dist;
            
            const ngx = Math.floor(nx / CONFIG.TILE_SIZE);
            const ngy = Math.floor(ny / CONFIG.TILE_SIZE);
            const tile = this.world.getTile(ngx, ngy);
            
            // NEW CHECK: Only spawn if elevation < 0.35 (Plains/Beach)
            const elevation = Utils.getElevation(ngx, ngy, this.world.seed);

            if (elevation < 0.35 && tile !== TILES.WATER.id && tile !== TILES.DEEP_WATER.id && !ID_TO_TILE[tile].solid) {
                this.npcs.push(new Entity(nx, ny, 'npc'));
            }
        }

        this.npcs.forEach(npc => {
            const ang = Math.atan2(this.player.y - npc.y, this.player.x - npc.x);
            npc.move(Math.cos(ang)*2, Math.sin(ang)*2, this.world);
            
            if (Utils.distance(npc, this.player) < CONFIG.TILE_SIZE) {
                if (!this.godMode) {
                    this.player.damageBuffer += 0.5; 
                    if (this.player.damageBuffer >= 1) {
                        const dmg = Math.floor(this.player.damageBuffer);
                        this.player.hp -= dmg;
                        this.player.damageBuffer -= dmg;
                        if (Math.random() > 0.8) this.spawnParticles(this.player.x, this.player.y, '#f00', 2);
                    }
                }
                if (dx||dy) {
                    npc.move(dx * 20, dy * 20, this.world); 
                    npc.hp -= 20;
                    this.spawnParticles(npc.x, npc.y, '#f00', 5);
                    this.spawnText(npc.x, npc.y, "20", "#fff");
                }
            }
        });
        
        this.cannons.forEach(c => {
            if (c.cooldown > 0) c.cooldown--;
            else if (c.ammo > 0) {
                let target = this.npcs.find(n => Utils.distance(c, n) < c.range);
                if (target) {
                    this.projectiles.push({x: c.x, y: c.y - CONFIG.TILE_SIZE, tx: target.x, ty: target.y, dmg: c.damage, active: true});
                    c.cooldown = 60;
                    this.spawnParticles(c.x, c.y - CONFIG.TILE_SIZE, '#aaa', 8);
                    if (!this.godMode) c.ammo--;
                }
            }
        });

        this.projectiles.forEach(p => {
            const ang = Math.atan2(p.ty - p.y, p.tx - p.x);
            p.x += Math.cos(ang) * 12; p.y += Math.sin(ang) * 12;
            this.npcs.forEach(n => {
                if (Utils.distance(p, n) < 16) {
                    p.active = false;
                    n.hp -= p.dmg;
                    this.spawnParticles(n.x, n.y, '#f00', 6);
                    this.spawnText(n.x, n.y, Math.floor(p.dmg), "#fff");
                }
            });
            if (Utils.distance(p, {x:p.tx, y:p.ty}) < 10) p.active = false;
        });

        this.npcs = this.npcs.filter(n => {
            if (n.hp <= 0) {
                const roll = Math.random();
                let dropId = TILES.GREY.id;
                let qty = 5;
                if (roll < 0.10) { dropId = TILES.GOLD.id; qty = 2; } 
                else if (roll < 0.40) { dropId = TILES.WOOD.id; qty = 5; } 
                else if (roll < 0.70) { dropId = TILES.IRON.id; qty = 5; } 
                else { dropId = TILES.GREY.id; qty = 8; }

                this.loot.push({x: n.x, y: n.y, id: dropId, qty: qty, bob: Math.random()*100});
                this.spawnParticles(n.x, n.y, '#f00', 10);
                return false;
            }
            return true;
        });
        this.projectiles = this.projectiles.filter(p => p.active);
        
        this.particles.forEach(p => p.update());
        this.particles = this.particles.filter(p => p.life > 0);
        this.texts.forEach(t => { t.y += t.dy; t.life--; });
        this.texts = this.texts.filter(t => t.life > 0);
        this.loot = this.loot.filter(l => {
            if (Utils.distance(this.player, l) < 32) {
                this.player.inventory[l.id] = (this.player.inventory[l.id]||0) + l.qty;
                this.spawnText(this.player.x, this.player.y - 30, `+${l.qty} ${ID_TO_TILE[l.id].short}`, "#ff0");
                this.updateUI();
                return false;
            }
            return true;
        });

        // DEBUG DISPLAY
        this.dom.hp.innerText = Math.floor(this.player.hp);
        const px = Math.floor(this.player.x/CONFIG.TILE_SIZE);
        const py = Math.floor(this.player.y/CONFIG.TILE_SIZE);
        this.dom.coords.innerText = `${px}, ${py}`;
        
        // Show elevation and Biome Name
        const currentElev = Utils.getElevation(px, py, this.world.seed);
        const currentTileId = this.world.getTile(px, py);
        this.dom.elev.innerText = currentElev.toFixed(2);
        this.dom.biome.innerText = ID_TO_TILE[currentTileId].name;
        
        if (this.player.hp <= 0) location.reload();
        
        this.input.flush();
    }

    drawHealth(e) {
        const w = 24, h = 4;
        const x = e.x - w/2, y = e.y - CONFIG.TILE_SIZE/2 - 8;
        this.ctx.fillStyle = '#300'; this.ctx.fillRect(x, y, w, h);
        this.ctx.fillStyle = '#0f0'; this.ctx.fillRect(x, y, w * (Math.max(0,e.hp)/100), h);
    }

    draw() {
        this.ctx.fillStyle = '#1a1a1a';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        this.ctx.save();
        this.ctx.scale(this.zoom, this.zoom);
        this.ctx.translate(-this.camera.x, -this.camera.y);

        const startCol = Math.floor(this.camera.x / CONFIG.TILE_SIZE);
        const endCol = startCol + (this.canvas.width / this.zoom / CONFIG.TILE_SIZE) + 1;
        const startRow = Math.floor(this.camera.y / CONFIG.TILE_SIZE);
        const endRow = startRow + (this.canvas.height / this.zoom / CONFIG.TILE_SIZE) + 1;

        const rowBuckets = {};
        const addToBucket = (obj, type) => {
            const r = Math.floor(obj.y / CONFIG.TILE_SIZE);
            if (!rowBuckets[r]) rowBuckets[r] = [];
            rowBuckets[r].push({ ...obj, _type: type, _orig: obj });
        };

        this.npcs.forEach(n => addToBucket(n, 'npc'));
        addToBucket(this.player, 'player');
        this.loot.forEach(l => addToBucket(l, 'loot'));

        // PASS 1: GROUND
        for (let r = startRow - 2; r <= endRow; r++) {
            for (let c = startCol; c <= endCol; c++) {
                const id = this.world.getTile(c, r);
                const tile = ID_TO_TILE[id];
                if (!tile) continue;

                if ((!tile.solid || id === TILES.WATER.id || id === TILES.DEEP_WATER.id) && id !== TILES.TREE.id) {
                    const tx = c * CONFIG.TILE_SIZE;
                    const ty = r * CONFIG.TILE_SIZE;
                    this.ctx.fillStyle = tile.color;
                    this.ctx.fillRect(tx, ty, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);
                }
                
                if (id === TILES.TREE.id || id === TILES.MOUNTAIN.id) {
                     const tx = c * CONFIG.TILE_SIZE;
                     const ty = r * CONFIG.TILE_SIZE;
                     this.ctx.fillStyle = TILES.GRASS.color; 
                     this.ctx.fillRect(tx, ty, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);
                }
            }
        }

        // PASS 2: OBJECTS
        for (let r = startRow - 2; r <= endRow; r++) { 
            // A. Static Structures
            for (let c = startCol; c <= endCol; c++) {
                const id = this.world.getTile(c, r);
                const tile = ID_TO_TILE[id];
                if (!tile) continue;
                
                const tx = c * CONFIG.TILE_SIZE;
                const ty = r * CONFIG.TILE_SIZE;

                // FIX: Exclude STONE_BLOCK from generic rendering
                if (tile.solid && 
                    id !== TILES.WATER.id && 
                    id !== TILES.DEEP_WATER.id && 
                    id !== TILES.TREE.id && 
                    id !== TILES.MOUNTAIN.id && 
                    id !== TILES.STONE_BLOCK.id && 
                    ![12, 14, 15].includes(id)) 
                {
                    this.ctx.fillStyle = tile.color;
                    this.ctx.fillRect(tx, ty, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);
                    // Shadows
                    this.ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    this.ctx.fillRect(tx + CONFIG.TILE_SIZE - 4, ty, 4, CONFIG.TILE_SIZE); 
                    this.ctx.fillRect(tx, ty + CONFIG.TILE_SIZE - 4, CONFIG.TILE_SIZE, 4); 
                    this.ctx.fillStyle = 'rgba(255,255,255,0.1)';
                    this.ctx.fillRect(tx, ty, CONFIG.TILE_SIZE, 4); 
                    this.ctx.fillRect(tx, ty, 4, CONFIG.TILE_SIZE); 
                    // Borders
                    this.ctx.lineWidth = 1;
                    this.ctx.strokeStyle = 'rgba(0,0,0,0.5)';
                    this.ctx.strokeRect(tx, ty, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);
                }
                
                // --- NEW BOULDER RENDERING ---
                if (id === TILES.STONE_BLOCK.id) {
                    // NEW: Draw Grass Background for Boulder
                    this.ctx.fillStyle = TILES.GRASS.color;
                    this.ctx.fillRect(tx, ty, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);

                    const shapeR = Utils.noise(c, r, this.world.seed + 777);
                    // Varied Stone Color
                    this.ctx.fillStyle = Utils.hsl(0, 0, 55, c, r, this.world.seed, 0, 10);

                    if (shapeR < 0.33) {
                        // Shape 1: Roundish Boulder
                        this.ctx.fillRect(tx + 4, ty + 4, 24, 24);
                        this.ctx.fillRect(tx + 2, ty + 8, 4, 16); // Left bulge
                        this.ctx.fillRect(tx + 26, ty + 8, 4, 16); // Right bulge
                        this.ctx.fillRect(tx + 8, ty + 2, 16, 4); // Top bulge
                        this.ctx.fillRect(tx + 8, ty + 26, 16, 4); // Bottom bulge
                        
                        // Highlight
                        this.ctx.fillStyle = 'rgba(255,255,255,0.1)';
                        this.ctx.fillRect(tx + 8, ty + 6, 8, 4);
                        // Shadow
                        this.ctx.fillStyle = 'rgba(0,0,0,0.2)';
                        this.ctx.fillRect(tx + 8, ty + 22, 16, 6);
                    } else if (shapeR < 0.66) {
                        // Shape 2: Heavy Slab / Flat Rock
                        this.ctx.fillRect(tx + 2, ty + 12, 28, 18);
                        this.ctx.fillRect(tx + 6, ty + 8, 20, 4);
                        
                        // Highlight
                        this.ctx.fillStyle = 'rgba(255,255,255,0.1)';
                        this.ctx.fillRect(tx + 6, ty + 8, 20, 2);
                        // Shadow
                        this.ctx.fillStyle = 'rgba(0,0,0,0.2)';
                        this.ctx.fillRect(tx + 22, ty + 12, 8, 18);
                    } else {
                        // Shape 3: Rock Cluster
                        this.ctx.fillRect(tx + 2, ty + 14, 12, 14); // Small left
                        this.ctx.fillRect(tx + 12, ty + 6, 18, 22); // Big right
                        
                        // Highlight
                        this.ctx.fillStyle = 'rgba(255,255,255,0.1)';
                        this.ctx.fillRect(tx + 14, ty + 6, 10, 4);
                        // Shadow
                        this.ctx.fillStyle = 'rgba(0,0,0,0.2)';
                        this.ctx.fillRect(tx + 8, ty + 20, 6, 8);
                    }
                }

                // Harvest Health Bar for Stone/Mountain
                if (id === TILES.MOUNTAIN.id || id === TILES.STONE_BLOCK.id) {
                    const dmg = this.world.getTileDamage(c, r);
                    if (dmg > 0) {
                        const max = 100;
                        const w = 24;
                        const h = 4;
                        const bx = tx + 4;
                        const by = ty - 10;
                        this.ctx.fillStyle = '#300';
                        this.ctx.fillRect(bx, by, w, h);
                        this.ctx.fillStyle = '#fff';
                        this.ctx.fillRect(bx, by, w * ((max - dmg) / max), h);
                    }
                }

                if (id === TILES.MOUNTAIN.id) {
                    // Varied GREY
                    this.ctx.fillStyle = Utils.hsl(0, 0, 60, c, r, this.world.seed, 0, 15);
                    this.ctx.fillRect(tx, ty - 8, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE + 8); 
                    this.ctx.fillStyle = 'rgba(0,0,0,0.3)';
                    this.ctx.fillRect(tx + CONFIG.TILE_SIZE - 4, ty - 8, 4, CONFIG.TILE_SIZE + 8);
                    this.ctx.fillStyle = '#eee'; 
                    this.ctx.fillRect(tx + 4, ty - 8, CONFIG.TILE_SIZE - 8, 8);
                }

                if (id === TILES.TREE.id) {
                    let isOccluding = false;
                    for (let checkR = r - 2; checkR < r; checkR++) {
                        if (rowBuckets[checkR] && rowBuckets[checkR].some(e => Math.floor(e.x / CONFIG.TILE_SIZE) === c)) isOccluding = true;
                    }
                    this.ctx.globalAlpha = isOccluding ? 0.4 : 1.0;
                    
                    // Trunk varied
                    this.ctx.fillStyle = Utils.hsl(25, 57, 23, c, r, this.world.seed + 100, 5, 5);
                    this.ctx.fillRect(tx + 12, ty - 8, 8, 24); 
                    
                    // Leaves varied color
                    this.ctx.fillStyle = Utils.hsl(120, 61, 34, c, r, this.world.seed, 15, 10);
                    
                    // Randomized Tree Shape
                    const shapeR = Utils.noise(c, r, this.world.seed + 555);
                    
                    if (shapeR < 0.33) {
                        // Shape 1: Classic Boxy
                        this.ctx.fillRect(tx, ty - 24, 32, 24);
                        // Shadow
                        this.ctx.fillStyle = 'rgba(0, 60, 0, 0.3)';
                        this.ctx.fillRect(tx + 4, ty - 20, 24, 16);
                    } else if (shapeR < 0.66) {
                        // Shape 2: Tall / Pine-like
                        this.ctx.fillRect(tx + 2, ty - 16, 28, 16); // Bottom Tier
                        this.ctx.fillRect(tx + 6, ty - 30, 20, 14); // Top Tier
                        // Shadow
                        this.ctx.fillStyle = 'rgba(0, 60, 0, 0.3)';
                        this.ctx.fillRect(tx + 8, ty - 26, 16, 22);
                    } else {
                        // Shape 3: Wide / Bushy
                        this.ctx.fillRect(tx - 2, ty - 20, 36, 20); // Main Body (Wider)
                        this.ctx.fillRect(tx + 6, ty - 26, 20, 6); // Top Cap
                        // Shadow
                        this.ctx.fillStyle = 'rgba(0, 60, 0, 0.3)';
                        this.ctx.fillRect(tx + 4, ty - 16, 24, 12);
                    }

                    this.ctx.globalAlpha = 1.0;
                }

                // Draw TALL STRUCTURES (Decorations)
                if ([12, 14, 15].includes(id)) {
                    // Check for Occlusion
                    let isOccluding = false;
                    for (let checkR = r - 2; checkR < r; checkR++) {
                        if (rowBuckets[checkR]) {
                            if (rowBuckets[checkR].some(e => Math.floor(e.x / CONFIG.TILE_SIZE) === c)) isOccluding = true;
                        }
                    }

                    this.ctx.globalAlpha = isOccluding ? 0.4 : 1.0;

                    // Draw the Base Block (which was skipped above)
                    this.ctx.fillStyle = tile.color;
                    this.ctx.fillRect(tx, ty, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);
                    
                    // Restore Depth Shadows for Tower Base
                    this.ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    this.ctx.fillRect(tx + CONFIG.TILE_SIZE - 4, ty, 4, CONFIG.TILE_SIZE); 
                    this.ctx.fillRect(tx, ty + CONFIG.TILE_SIZE - 4, CONFIG.TILE_SIZE, 4); 
                    this.ctx.fillStyle = 'rgba(255,255,255,0.1)';
                    this.ctx.fillRect(tx, ty, CONFIG.TILE_SIZE, 4); 
                    this.ctx.fillRect(tx, ty, 4, CONFIG.TILE_SIZE); 

                    this.ctx.strokeRect(tx, ty, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);

                    // Barrel
                    this.ctx.fillStyle = (id===14 ? '#444' : id===15 ? '#ffd700' : '#777');
                    this.ctx.fillRect(tx, ty - CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);
                    this.ctx.strokeRect(tx, ty - CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);
                    
                    // Roof
                    this.ctx.fillStyle = '#5C3317';
                    this.ctx.beginPath();
                    this.ctx.moveTo(tx, ty - CONFIG.TILE_SIZE);
                    this.ctx.lineTo(tx + CONFIG.TILE_SIZE, ty - CONFIG.TILE_SIZE);
                    this.ctx.lineTo(tx + CONFIG.TILE_SIZE/2, ty - CONFIG.TILE_SIZE*2);
                    this.ctx.closePath();
                    this.ctx.fill();
                    this.ctx.stroke();

                    const cannon = this.cannons.find(can => can.key === `${c},${r}`);
                    if (cannon) {
                        this.ctx.fillStyle = cannon.ammo > 0 ? '#0ff' : '#f00';
                        this.ctx.font = '10px monospace';
                        this.ctx.fillText(cannon.ammo, tx + 10, ty + 20);
                    }
                    this.ctx.globalAlpha = 1.0;
                }
            }

            // B. Entities & Loot
            if (rowBuckets[r]) {
                rowBuckets[r].forEach(obj => {
                    if (obj._type === 'loot') {
                        const bob = Math.sin((Date.now()/200) + obj.bob) * 3;
                        this.ctx.fillStyle = ID_TO_TILE[obj.id].color;
                        this.ctx.fillRect(obj.x - 6, obj.y - 6 + bob, 12, 12);
                    } else {
                        this.ctx.fillStyle = obj._type === 'player' ? '#ff0000' : '#aa0000';
                        this.ctx.fillRect(obj.x - 16, obj.y - 16, 32, 32);
                        this.drawHealth(obj._orig); 
                    }
                });
            }
        }

        this.ctx.fillStyle = '#fff';
        this.projectiles.forEach(p => {
            this.ctx.beginPath();
            this.ctx.arc(p.x, p.y, 4, 0, 6.28);
            this.ctx.fill();
        });

        this.particles.forEach(p => p.draw(this.ctx, 0, 0)); 

        if (this.activeBlueprint) {
            const mx = (this.input.mouse.x / this.zoom) + this.camera.x;
            const my = (this.input.mouse.y / this.zoom) + this.camera.y;
            const gx = Math.floor(mx / CONFIG.TILE_SIZE);
            const gy = Math.floor(my / CONFIG.TILE_SIZE);
            
            this.ctx.globalAlpha = 0.5;
            this.activeBlueprint.structure.forEach(part => {
                const tile = ID_TO_TILE[part.id];
                this.ctx.fillStyle = tile.color;
                this.ctx.fillRect((gx + part.x) * CONFIG.TILE_SIZE, (gy + part.y) * CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);
            });
            this.ctx.globalAlpha = 1.0;
            
            this.ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            this.ctx.beginPath();
            this.ctx.arc(this.player.x, this.player.y, CONFIG.BUILD_RANGE, 0, 6.28);
            this.ctx.stroke();
        }
        
        this.ctx.font = "bold 14px monospace";
        this.texts.forEach(t => {
            this.ctx.fillStyle = t.col;
            this.ctx.fillText(t.txt, t.x, t.y);
        });

        this.ctx.restore();
    }

    loop(timestamp) {
        const dt = timestamp - this.lastTime;
        this.lastTime = timestamp;
        this.update(dt);
        this.draw();
        requestAnimationFrame(t => this.loop(t));
    }
}

window.onload = () => new Game();
</script>
</body>
</html>